<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>两天时间，实现自己的 Promise | 前端收集</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.webp">
    <link rel="manifest" href="/manifest.json">
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="blog,react,node,js">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.ae400df5.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/203.4ebeba02.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/100.f9ccbc6f.js"><link rel="prefetch" href="/assets/js/101.c20baa36.js"><link rel="prefetch" href="/assets/js/102.4ce575e4.js"><link rel="prefetch" href="/assets/js/103.6ddf9f4a.js"><link rel="prefetch" href="/assets/js/104.e8bd0c3f.js"><link rel="prefetch" href="/assets/js/105.d0a85c47.js"><link rel="prefetch" href="/assets/js/106.4b3aadee.js"><link rel="prefetch" href="/assets/js/107.436e7f8f.js"><link rel="prefetch" href="/assets/js/108.f46692dc.js"><link rel="prefetch" href="/assets/js/109.322908a6.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/110.9181da82.js"><link rel="prefetch" href="/assets/js/111.c451b4da.js"><link rel="prefetch" href="/assets/js/112.196b195d.js"><link rel="prefetch" href="/assets/js/113.d65148d0.js"><link rel="prefetch" href="/assets/js/114.5566de19.js"><link rel="prefetch" href="/assets/js/115.12d1619e.js"><link rel="prefetch" href="/assets/js/116.d2f23fe7.js"><link rel="prefetch" href="/assets/js/117.d5fa2588.js"><link rel="prefetch" href="/assets/js/118.79455d12.js"><link rel="prefetch" href="/assets/js/119.b43c99e9.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/120.f321d53f.js"><link rel="prefetch" href="/assets/js/121.286fed99.js"><link rel="prefetch" href="/assets/js/122.ff0af27d.js"><link rel="prefetch" href="/assets/js/123.00138c02.js"><link rel="prefetch" href="/assets/js/124.25640250.js"><link rel="prefetch" href="/assets/js/125.cb2f28a6.js"><link rel="prefetch" href="/assets/js/126.e8ec0fe7.js"><link rel="prefetch" href="/assets/js/127.0fdd48c2.js"><link rel="prefetch" href="/assets/js/128.38b675a9.js"><link rel="prefetch" href="/assets/js/129.7819df5c.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/130.a58f0a09.js"><link rel="prefetch" href="/assets/js/131.4a0133b5.js"><link rel="prefetch" href="/assets/js/132.24e842c4.js"><link rel="prefetch" href="/assets/js/133.be3bb854.js"><link rel="prefetch" href="/assets/js/134.8c4662c6.js"><link rel="prefetch" href="/assets/js/135.03d2f395.js"><link rel="prefetch" href="/assets/js/136.acf07647.js"><link rel="prefetch" href="/assets/js/137.f0fa48ad.js"><link rel="prefetch" href="/assets/js/138.843d86f2.js"><link rel="prefetch" href="/assets/js/139.015086b5.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/140.5468056b.js"><link rel="prefetch" href="/assets/js/141.9bf65de6.js"><link rel="prefetch" href="/assets/js/142.63b38359.js"><link rel="prefetch" href="/assets/js/143.55120954.js"><link rel="prefetch" href="/assets/js/144.e3d71ef2.js"><link rel="prefetch" href="/assets/js/145.470a4869.js"><link rel="prefetch" href="/assets/js/146.574b3929.js"><link rel="prefetch" href="/assets/js/147.28c0b405.js"><link rel="prefetch" href="/assets/js/148.08f963f8.js"><link rel="prefetch" href="/assets/js/149.0b296978.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/150.651bd19a.js"><link rel="prefetch" href="/assets/js/151.d2029876.js"><link rel="prefetch" href="/assets/js/152.32f253ce.js"><link rel="prefetch" href="/assets/js/153.ceb29b56.js"><link rel="prefetch" href="/assets/js/154.6a7f6d29.js"><link rel="prefetch" href="/assets/js/155.50aaf5d9.js"><link rel="prefetch" href="/assets/js/156.036e250b.js"><link rel="prefetch" href="/assets/js/157.c2435840.js"><link rel="prefetch" href="/assets/js/158.242ba411.js"><link rel="prefetch" href="/assets/js/159.136ff0a3.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/160.25dcaecf.js"><link rel="prefetch" href="/assets/js/161.ab904d4e.js"><link rel="prefetch" href="/assets/js/162.04b69881.js"><link rel="prefetch" href="/assets/js/163.e7e749f8.js"><link rel="prefetch" href="/assets/js/164.71f53227.js"><link rel="prefetch" href="/assets/js/165.5841cd1a.js"><link rel="prefetch" href="/assets/js/166.28071d6e.js"><link rel="prefetch" href="/assets/js/167.93ce97d2.js"><link rel="prefetch" href="/assets/js/168.f3b2972c.js"><link rel="prefetch" href="/assets/js/169.aa7f77f0.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/170.cfdf36f3.js"><link rel="prefetch" href="/assets/js/171.e542ad9a.js"><link rel="prefetch" href="/assets/js/172.2101f9ed.js"><link rel="prefetch" href="/assets/js/173.8f875d74.js"><link rel="prefetch" href="/assets/js/174.61572c8b.js"><link rel="prefetch" href="/assets/js/175.2ce966d7.js"><link rel="prefetch" href="/assets/js/176.bf7661ff.js"><link rel="prefetch" href="/assets/js/177.99ab75ff.js"><link rel="prefetch" href="/assets/js/178.8c053eff.js"><link rel="prefetch" href="/assets/js/179.bb56672f.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/180.44be886d.js"><link rel="prefetch" href="/assets/js/181.a635f8b4.js"><link rel="prefetch" href="/assets/js/182.43ee494e.js"><link rel="prefetch" href="/assets/js/183.7f8013e7.js"><link rel="prefetch" href="/assets/js/184.995eba6d.js"><link rel="prefetch" href="/assets/js/185.ae8dc8fc.js"><link rel="prefetch" href="/assets/js/186.f5f3b8d8.js"><link rel="prefetch" href="/assets/js/187.0b834066.js"><link rel="prefetch" href="/assets/js/188.de0798b4.js"><link rel="prefetch" href="/assets/js/189.bd73bd48.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/190.3b34618c.js"><link rel="prefetch" href="/assets/js/191.d69ac5ae.js"><link rel="prefetch" href="/assets/js/192.6fb41323.js"><link rel="prefetch" href="/assets/js/193.deec3471.js"><link rel="prefetch" href="/assets/js/194.a936f543.js"><link rel="prefetch" href="/assets/js/195.257a9d86.js"><link rel="prefetch" href="/assets/js/196.b04a1424.js"><link rel="prefetch" href="/assets/js/197.b1b12256.js"><link rel="prefetch" href="/assets/js/198.d3539378.js"><link rel="prefetch" href="/assets/js/199.802facc3.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/200.c2e3da4f.js"><link rel="prefetch" href="/assets/js/201.9b119f49.js"><link rel="prefetch" href="/assets/js/202.283e51cb.js"><link rel="prefetch" href="/assets/js/204.a3680104.js"><link rel="prefetch" href="/assets/js/205.e89e1221.js"><link rel="prefetch" href="/assets/js/206.a2159b40.js"><link rel="prefetch" href="/assets/js/207.30aa8a56.js"><link rel="prefetch" href="/assets/js/208.25e87523.js"><link rel="prefetch" href="/assets/js/209.1feb11d6.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/210.3988d49f.js"><link rel="prefetch" href="/assets/js/211.c35b6127.js"><link rel="prefetch" href="/assets/js/212.a47a605d.js"><link rel="prefetch" href="/assets/js/213.e67c2145.js"><link rel="prefetch" href="/assets/js/214.f2adf5ee.js"><link rel="prefetch" href="/assets/js/215.8af7fa44.js"><link rel="prefetch" href="/assets/js/216.c4c02e18.js"><link rel="prefetch" href="/assets/js/217.8a2ed0a4.js"><link rel="prefetch" href="/assets/js/218.5224a21c.js"><link rel="prefetch" href="/assets/js/219.85a23ded.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/220.1a4b37cb.js"><link rel="prefetch" href="/assets/js/221.fd8b42a5.js"><link rel="prefetch" href="/assets/js/222.ab3b9c2e.js"><link rel="prefetch" href="/assets/js/223.7e579d8f.js"><link rel="prefetch" href="/assets/js/224.a9ba827c.js"><link rel="prefetch" href="/assets/js/225.e1612fcc.js"><link rel="prefetch" href="/assets/js/226.9c1af133.js"><link rel="prefetch" href="/assets/js/227.0bc3b51e.js"><link rel="prefetch" href="/assets/js/228.a0eba8af.js"><link rel="prefetch" href="/assets/js/229.5d1c84bb.js"><link rel="prefetch" href="/assets/js/23.79aa69fa.js"><link rel="prefetch" href="/assets/js/230.f83fdc59.js"><link rel="prefetch" href="/assets/js/231.9f82cedb.js"><link rel="prefetch" href="/assets/js/232.f97914ee.js"><link rel="prefetch" href="/assets/js/233.50ac2baa.js"><link rel="prefetch" href="/assets/js/234.d313f866.js"><link rel="prefetch" href="/assets/js/235.f5eb3748.js"><link rel="prefetch" href="/assets/js/236.d452db47.js"><link rel="prefetch" href="/assets/js/237.5199378b.js"><link rel="prefetch" href="/assets/js/238.d1c3107c.js"><link rel="prefetch" href="/assets/js/239.4e2b6d59.js"><link rel="prefetch" href="/assets/js/24.03ffbcca.js"><link rel="prefetch" href="/assets/js/240.b46f5ecd.js"><link rel="prefetch" href="/assets/js/241.7e9311b0.js"><link rel="prefetch" href="/assets/js/242.ede280f9.js"><link rel="prefetch" href="/assets/js/243.71efdf6e.js"><link rel="prefetch" href="/assets/js/244.1b089d77.js"><link rel="prefetch" href="/assets/js/245.47562a1b.js"><link rel="prefetch" href="/assets/js/246.35ce7ccb.js"><link rel="prefetch" href="/assets/js/247.0eea6dda.js"><link rel="prefetch" href="/assets/js/248.d606d51a.js"><link rel="prefetch" href="/assets/js/249.22a9c555.js"><link rel="prefetch" href="/assets/js/25.872464d2.js"><link rel="prefetch" href="/assets/js/250.7cf64a15.js"><link rel="prefetch" href="/assets/js/251.b6f787d7.js"><link rel="prefetch" href="/assets/js/252.8b9bedcd.js"><link rel="prefetch" href="/assets/js/253.5c63ec35.js"><link rel="prefetch" href="/assets/js/254.31ff9dc4.js"><link rel="prefetch" href="/assets/js/255.190e5f80.js"><link rel="prefetch" href="/assets/js/256.e68f87e0.js"><link rel="prefetch" href="/assets/js/257.3095f7a1.js"><link rel="prefetch" href="/assets/js/258.af517699.js"><link rel="prefetch" href="/assets/js/259.f10ece0f.js"><link rel="prefetch" href="/assets/js/26.bd6d2ac2.js"><link rel="prefetch" href="/assets/js/260.e8bbba00.js"><link rel="prefetch" href="/assets/js/261.5d9b1d5e.js"><link rel="prefetch" href="/assets/js/262.950474a9.js"><link rel="prefetch" href="/assets/js/263.3e7dca65.js"><link rel="prefetch" href="/assets/js/264.1017ad1a.js"><link rel="prefetch" href="/assets/js/265.99c4d846.js"><link rel="prefetch" href="/assets/js/266.8d1ea647.js"><link rel="prefetch" href="/assets/js/267.20e69579.js"><link rel="prefetch" href="/assets/js/268.4da84374.js"><link rel="prefetch" href="/assets/js/269.e3ad7859.js"><link rel="prefetch" href="/assets/js/27.814c713d.js"><link rel="prefetch" href="/assets/js/270.c5c4b40b.js"><link rel="prefetch" href="/assets/js/271.9c7294fd.js"><link rel="prefetch" href="/assets/js/272.3d41fdce.js"><link rel="prefetch" href="/assets/js/273.3eaafe8e.js"><link rel="prefetch" href="/assets/js/274.f98d5554.js"><link rel="prefetch" href="/assets/js/275.5ec6a4b8.js"><link rel="prefetch" href="/assets/js/276.0936dd89.js"><link rel="prefetch" href="/assets/js/277.33bd4dff.js"><link rel="prefetch" href="/assets/js/278.c383b31c.js"><link rel="prefetch" href="/assets/js/279.6df8b215.js"><link rel="prefetch" href="/assets/js/28.5229eb08.js"><link rel="prefetch" href="/assets/js/280.07169fc6.js"><link rel="prefetch" href="/assets/js/281.4b28be3f.js"><link rel="prefetch" href="/assets/js/282.79bba86e.js"><link rel="prefetch" href="/assets/js/283.32f592bc.js"><link rel="prefetch" href="/assets/js/284.fd9b6b59.js"><link rel="prefetch" href="/assets/js/285.df1454be.js"><link rel="prefetch" href="/assets/js/286.18b1703e.js"><link rel="prefetch" href="/assets/js/287.94781ca0.js"><link rel="prefetch" href="/assets/js/288.f21493cb.js"><link rel="prefetch" href="/assets/js/289.8fc283e3.js"><link rel="prefetch" href="/assets/js/29.a63c1057.js"><link rel="prefetch" href="/assets/js/290.3346a986.js"><link rel="prefetch" href="/assets/js/291.5fafa49e.js"><link rel="prefetch" href="/assets/js/292.ac874de4.js"><link rel="prefetch" href="/assets/js/293.19730c32.js"><link rel="prefetch" href="/assets/js/294.98ddc6d7.js"><link rel="prefetch" href="/assets/js/295.eae00758.js"><link rel="prefetch" href="/assets/js/296.1d81c552.js"><link rel="prefetch" href="/assets/js/297.5f86f97e.js"><link rel="prefetch" href="/assets/js/298.1bc558ca.js"><link rel="prefetch" href="/assets/js/299.d068c6b6.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.1b884b1b.js"><link rel="prefetch" href="/assets/js/300.c956e204.js"><link rel="prefetch" href="/assets/js/301.77127d95.js"><link rel="prefetch" href="/assets/js/302.1d7c4af3.js"><link rel="prefetch" href="/assets/js/303.2bcbc099.js"><link rel="prefetch" href="/assets/js/304.b2180761.js"><link rel="prefetch" href="/assets/js/305.3ac4a62e.js"><link rel="prefetch" href="/assets/js/306.1ce3e68d.js"><link rel="prefetch" href="/assets/js/307.6c3d9548.js"><link rel="prefetch" href="/assets/js/308.b777fbfa.js"><link rel="prefetch" href="/assets/js/309.e5d32660.js"><link rel="prefetch" href="/assets/js/31.68c1b4eb.js"><link rel="prefetch" href="/assets/js/310.fcda8acc.js"><link rel="prefetch" href="/assets/js/311.cde4dc35.js"><link rel="prefetch" href="/assets/js/312.98a0ee89.js"><link rel="prefetch" href="/assets/js/313.ce02630f.js"><link rel="prefetch" href="/assets/js/314.3883ac39.js"><link rel="prefetch" href="/assets/js/315.b6c9cd37.js"><link rel="prefetch" href="/assets/js/316.6cd33ea7.js"><link rel="prefetch" href="/assets/js/317.eb818350.js"><link rel="prefetch" href="/assets/js/318.e9e7da16.js"><link rel="prefetch" href="/assets/js/319.1edfec0a.js"><link rel="prefetch" href="/assets/js/32.64224241.js"><link rel="prefetch" href="/assets/js/320.f4728475.js"><link rel="prefetch" href="/assets/js/321.799c6e59.js"><link rel="prefetch" href="/assets/js/322.a701407b.js"><link rel="prefetch" href="/assets/js/323.803b7bcc.js"><link rel="prefetch" href="/assets/js/324.a73b88d8.js"><link rel="prefetch" href="/assets/js/325.f08e06ca.js"><link rel="prefetch" href="/assets/js/326.80813d35.js"><link rel="prefetch" href="/assets/js/327.8310d6c8.js"><link rel="prefetch" href="/assets/js/328.68f1b07a.js"><link rel="prefetch" href="/assets/js/329.04be32fe.js"><link rel="prefetch" href="/assets/js/33.b4859866.js"><link rel="prefetch" href="/assets/js/330.fbd486d3.js"><link rel="prefetch" href="/assets/js/331.bc43b814.js"><link rel="prefetch" href="/assets/js/332.838514e5.js"><link rel="prefetch" href="/assets/js/333.c647f10b.js"><link rel="prefetch" href="/assets/js/334.293d7db1.js"><link rel="prefetch" href="/assets/js/335.f60f98c5.js"><link rel="prefetch" href="/assets/js/336.d59a627e.js"><link rel="prefetch" href="/assets/js/337.719cd005.js"><link rel="prefetch" href="/assets/js/338.eb93d4b7.js"><link rel="prefetch" href="/assets/js/339.a38c5695.js"><link rel="prefetch" href="/assets/js/34.69c1bc55.js"><link rel="prefetch" href="/assets/js/340.9a4ce427.js"><link rel="prefetch" href="/assets/js/341.d39b4f2f.js"><link rel="prefetch" href="/assets/js/342.11fbba88.js"><link rel="prefetch" href="/assets/js/343.36030f9c.js"><link rel="prefetch" href="/assets/js/344.94fc0ac0.js"><link rel="prefetch" href="/assets/js/345.c6ef0cd3.js"><link rel="prefetch" href="/assets/js/346.3f3484bf.js"><link rel="prefetch" href="/assets/js/347.f6957922.js"><link rel="prefetch" href="/assets/js/348.df8650b3.js"><link rel="prefetch" href="/assets/js/349.402ca2e1.js"><link rel="prefetch" href="/assets/js/35.d8b00796.js"><link rel="prefetch" href="/assets/js/350.8a48f4c3.js"><link rel="prefetch" href="/assets/js/351.b5356e83.js"><link rel="prefetch" href="/assets/js/352.944301fd.js"><link rel="prefetch" href="/assets/js/353.8b170c06.js"><link rel="prefetch" href="/assets/js/354.97b92290.js"><link rel="prefetch" href="/assets/js/355.948e7095.js"><link rel="prefetch" href="/assets/js/356.5aaf9fe5.js"><link rel="prefetch" href="/assets/js/357.67c88167.js"><link rel="prefetch" href="/assets/js/358.e241fbe2.js"><link rel="prefetch" href="/assets/js/359.15b3166a.js"><link rel="prefetch" href="/assets/js/36.090e85b2.js"><link rel="prefetch" href="/assets/js/360.187f4fe6.js"><link rel="prefetch" href="/assets/js/361.a77fa57f.js"><link rel="prefetch" href="/assets/js/362.30ed8657.js"><link rel="prefetch" href="/assets/js/363.c8caaf0f.js"><link rel="prefetch" href="/assets/js/364.78f41e2e.js"><link rel="prefetch" href="/assets/js/365.55b8d5b3.js"><link rel="prefetch" href="/assets/js/366.d1c007ca.js"><link rel="prefetch" href="/assets/js/367.bc6a31fb.js"><link rel="prefetch" href="/assets/js/368.147012d3.js"><link rel="prefetch" href="/assets/js/369.94f25d03.js"><link rel="prefetch" href="/assets/js/37.bf92df67.js"><link rel="prefetch" href="/assets/js/370.37c8786f.js"><link rel="prefetch" href="/assets/js/371.037e513b.js"><link rel="prefetch" href="/assets/js/372.353d4826.js"><link rel="prefetch" href="/assets/js/373.3260442b.js"><link rel="prefetch" href="/assets/js/374.eabaedd4.js"><link rel="prefetch" href="/assets/js/375.f80e9c75.js"><link rel="prefetch" href="/assets/js/376.b041cafe.js"><link rel="prefetch" href="/assets/js/377.d6410416.js"><link rel="prefetch" href="/assets/js/378.0d21f78f.js"><link rel="prefetch" href="/assets/js/379.83c05c56.js"><link rel="prefetch" href="/assets/js/38.74932844.js"><link rel="prefetch" href="/assets/js/380.c41e1704.js"><link rel="prefetch" href="/assets/js/381.52c6dcbf.js"><link rel="prefetch" href="/assets/js/382.d2998ea4.js"><link rel="prefetch" href="/assets/js/383.160918fa.js"><link rel="prefetch" href="/assets/js/384.6e3e4604.js"><link rel="prefetch" href="/assets/js/385.e514c0b7.js"><link rel="prefetch" href="/assets/js/386.3cab7b43.js"><link rel="prefetch" href="/assets/js/387.7b7aa4c3.js"><link rel="prefetch" href="/assets/js/388.1675a9c8.js"><link rel="prefetch" href="/assets/js/389.f5e5e9e4.js"><link rel="prefetch" href="/assets/js/39.45a654d9.js"><link rel="prefetch" href="/assets/js/390.5bbca72c.js"><link rel="prefetch" href="/assets/js/391.4e95a939.js"><link rel="prefetch" href="/assets/js/392.8eb7d12f.js"><link rel="prefetch" href="/assets/js/393.f72f9473.js"><link rel="prefetch" href="/assets/js/394.1cea58b3.js"><link rel="prefetch" href="/assets/js/395.33fa0847.js"><link rel="prefetch" href="/assets/js/396.8ef17642.js"><link rel="prefetch" href="/assets/js/397.dd02eee1.js"><link rel="prefetch" href="/assets/js/398.23ea33a3.js"><link rel="prefetch" href="/assets/js/399.84a4e8db.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.7cc37d90.js"><link rel="prefetch" href="/assets/js/400.0597181f.js"><link rel="prefetch" href="/assets/js/401.9cb4c0e2.js"><link rel="prefetch" href="/assets/js/402.41ddf5c4.js"><link rel="prefetch" href="/assets/js/403.afa305eb.js"><link rel="prefetch" href="/assets/js/404.3831ec8d.js"><link rel="prefetch" href="/assets/js/405.b79a51fb.js"><link rel="prefetch" href="/assets/js/406.dd6191a5.js"><link rel="prefetch" href="/assets/js/407.d2e12f04.js"><link rel="prefetch" href="/assets/js/408.56c2fc48.js"><link rel="prefetch" href="/assets/js/409.25a15725.js"><link rel="prefetch" href="/assets/js/41.78331f9e.js"><link rel="prefetch" href="/assets/js/410.dd6c1352.js"><link rel="prefetch" href="/assets/js/411.6d95d902.js"><link rel="prefetch" href="/assets/js/412.da6546bd.js"><link rel="prefetch" href="/assets/js/413.39d34e64.js"><link rel="prefetch" href="/assets/js/414.aaa215f3.js"><link rel="prefetch" href="/assets/js/415.b41c61b6.js"><link rel="prefetch" href="/assets/js/416.139592a7.js"><link rel="prefetch" href="/assets/js/417.324a89a1.js"><link rel="prefetch" href="/assets/js/418.676f7dcb.js"><link rel="prefetch" href="/assets/js/419.9350419c.js"><link rel="prefetch" href="/assets/js/42.a22391d6.js"><link rel="prefetch" href="/assets/js/420.0462f81e.js"><link rel="prefetch" href="/assets/js/421.a6efdd34.js"><link rel="prefetch" href="/assets/js/422.569428e8.js"><link rel="prefetch" href="/assets/js/423.8cb41fe5.js"><link rel="prefetch" href="/assets/js/424.98a9d128.js"><link rel="prefetch" href="/assets/js/425.62b51cfb.js"><link rel="prefetch" href="/assets/js/426.7b3a49e4.js"><link rel="prefetch" href="/assets/js/427.f99d9c10.js"><link rel="prefetch" href="/assets/js/428.73db8fe6.js"><link rel="prefetch" href="/assets/js/429.05f1741b.js"><link rel="prefetch" href="/assets/js/43.8946d7e2.js"><link rel="prefetch" href="/assets/js/430.8b43f070.js"><link rel="prefetch" href="/assets/js/431.d85a79d6.js"><link rel="prefetch" href="/assets/js/432.7373e34b.js"><link rel="prefetch" href="/assets/js/433.4be17add.js"><link rel="prefetch" href="/assets/js/434.81670bcf.js"><link rel="prefetch" href="/assets/js/435.6aa95ea5.js"><link rel="prefetch" href="/assets/js/436.4223c356.js"><link rel="prefetch" href="/assets/js/437.13f276dc.js"><link rel="prefetch" href="/assets/js/438.7c6e503d.js"><link rel="prefetch" href="/assets/js/439.6f9afc22.js"><link rel="prefetch" href="/assets/js/44.2a678f4a.js"><link rel="prefetch" href="/assets/js/440.5c949914.js"><link rel="prefetch" href="/assets/js/441.7dc7c8e4.js"><link rel="prefetch" href="/assets/js/442.bfec8250.js"><link rel="prefetch" href="/assets/js/443.0b932152.js"><link rel="prefetch" href="/assets/js/444.ecc56127.js"><link rel="prefetch" href="/assets/js/445.3a1eefa1.js"><link rel="prefetch" href="/assets/js/446.07410371.js"><link rel="prefetch" href="/assets/js/447.920996c3.js"><link rel="prefetch" href="/assets/js/448.9b5b5588.js"><link rel="prefetch" href="/assets/js/449.40afb76e.js"><link rel="prefetch" href="/assets/js/45.a716cdab.js"><link rel="prefetch" href="/assets/js/450.15845e93.js"><link rel="prefetch" href="/assets/js/451.c0454122.js"><link rel="prefetch" href="/assets/js/452.076ca38b.js"><link rel="prefetch" href="/assets/js/453.35add2cd.js"><link rel="prefetch" href="/assets/js/454.fed25dd2.js"><link rel="prefetch" href="/assets/js/455.a3232b7e.js"><link rel="prefetch" href="/assets/js/456.803d9cea.js"><link rel="prefetch" href="/assets/js/457.0a884768.js"><link rel="prefetch" href="/assets/js/458.69b6cc02.js"><link rel="prefetch" href="/assets/js/459.d8e1df18.js"><link rel="prefetch" href="/assets/js/46.53b78a16.js"><link rel="prefetch" href="/assets/js/460.a4980d6e.js"><link rel="prefetch" href="/assets/js/461.68d3e1c1.js"><link rel="prefetch" href="/assets/js/462.7930ea12.js"><link rel="prefetch" href="/assets/js/463.48a62ed8.js"><link rel="prefetch" href="/assets/js/464.5c42fe51.js"><link rel="prefetch" href="/assets/js/465.b65a0e95.js"><link rel="prefetch" href="/assets/js/466.63474609.js"><link rel="prefetch" href="/assets/js/467.e6370736.js"><link rel="prefetch" href="/assets/js/468.a6cd9285.js"><link rel="prefetch" href="/assets/js/469.3df61389.js"><link rel="prefetch" href="/assets/js/47.dc9468b3.js"><link rel="prefetch" href="/assets/js/470.b956e72b.js"><link rel="prefetch" href="/assets/js/471.227fb33d.js"><link rel="prefetch" href="/assets/js/472.407485a3.js"><link rel="prefetch" href="/assets/js/473.9ab2c50d.js"><link rel="prefetch" href="/assets/js/474.dd36f932.js"><link rel="prefetch" href="/assets/js/475.7634085c.js"><link rel="prefetch" href="/assets/js/476.6869c979.js"><link rel="prefetch" href="/assets/js/477.b8bbd1aa.js"><link rel="prefetch" href="/assets/js/478.d85549c5.js"><link rel="prefetch" href="/assets/js/479.a549954b.js"><link rel="prefetch" href="/assets/js/48.f62c6508.js"><link rel="prefetch" href="/assets/js/480.964f2b40.js"><link rel="prefetch" href="/assets/js/481.68f5f905.js"><link rel="prefetch" href="/assets/js/482.32b674c2.js"><link rel="prefetch" href="/assets/js/483.6574c15d.js"><link rel="prefetch" href="/assets/js/484.63db4bff.js"><link rel="prefetch" href="/assets/js/485.0ecd7c6e.js"><link rel="prefetch" href="/assets/js/486.44a1de5d.js"><link rel="prefetch" href="/assets/js/487.fad12e99.js"><link rel="prefetch" href="/assets/js/488.169f32db.js"><link rel="prefetch" href="/assets/js/489.7ea816a6.js"><link rel="prefetch" href="/assets/js/49.f155d78a.js"><link rel="prefetch" href="/assets/js/490.d35de876.js"><link rel="prefetch" href="/assets/js/491.08874d90.js"><link rel="prefetch" href="/assets/js/492.088a7e6e.js"><link rel="prefetch" href="/assets/js/493.61d62bf4.js"><link rel="prefetch" href="/assets/js/494.b0515138.js"><link rel="prefetch" href="/assets/js/495.60587f26.js"><link rel="prefetch" href="/assets/js/496.d66df398.js"><link rel="prefetch" href="/assets/js/497.7c88f879.js"><link rel="prefetch" href="/assets/js/498.73e1e0cf.js"><link rel="prefetch" href="/assets/js/499.8162e0b6.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.d2b62498.js"><link rel="prefetch" href="/assets/js/500.8b0de440.js"><link rel="prefetch" href="/assets/js/501.0894844d.js"><link rel="prefetch" href="/assets/js/502.1c0d1c3c.js"><link rel="prefetch" href="/assets/js/503.3e3f2a4a.js"><link rel="prefetch" href="/assets/js/504.cca812a4.js"><link rel="prefetch" href="/assets/js/505.8a1f3adc.js"><link rel="prefetch" href="/assets/js/506.35d49763.js"><link rel="prefetch" href="/assets/js/507.4fd3c268.js"><link rel="prefetch" href="/assets/js/508.aa2ba78c.js"><link rel="prefetch" href="/assets/js/509.cc7d97eb.js"><link rel="prefetch" href="/assets/js/51.7b12b0f0.js"><link rel="prefetch" href="/assets/js/510.73e3254c.js"><link rel="prefetch" href="/assets/js/511.bd21926b.js"><link rel="prefetch" href="/assets/js/512.8b796161.js"><link rel="prefetch" href="/assets/js/513.da11e0bf.js"><link rel="prefetch" href="/assets/js/514.5a620685.js"><link rel="prefetch" href="/assets/js/515.9a4b1681.js"><link rel="prefetch" href="/assets/js/516.de55e3ca.js"><link rel="prefetch" href="/assets/js/517.2b3b1dd5.js"><link rel="prefetch" href="/assets/js/518.aa28e969.js"><link rel="prefetch" href="/assets/js/519.91a752a1.js"><link rel="prefetch" href="/assets/js/52.3391993d.js"><link rel="prefetch" href="/assets/js/520.49c84d3e.js"><link rel="prefetch" href="/assets/js/521.545008de.js"><link rel="prefetch" href="/assets/js/522.11773c74.js"><link rel="prefetch" href="/assets/js/523.5b523166.js"><link rel="prefetch" href="/assets/js/524.9d7c8f5c.js"><link rel="prefetch" href="/assets/js/53.a67a7068.js"><link rel="prefetch" href="/assets/js/54.af0dccf3.js"><link rel="prefetch" href="/assets/js/55.cdae5880.js"><link rel="prefetch" href="/assets/js/56.4d918bef.js"><link rel="prefetch" href="/assets/js/57.5e9dea12.js"><link rel="prefetch" href="/assets/js/58.6cec08ff.js"><link rel="prefetch" href="/assets/js/59.65771179.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/60.8f859a65.js"><link rel="prefetch" href="/assets/js/61.43bff54c.js"><link rel="prefetch" href="/assets/js/62.b8e9e509.js"><link rel="prefetch" href="/assets/js/63.5149a7b9.js"><link rel="prefetch" href="/assets/js/64.961c386a.js"><link rel="prefetch" href="/assets/js/65.73f66baf.js"><link rel="prefetch" href="/assets/js/66.b5930577.js"><link rel="prefetch" href="/assets/js/67.40a0db0c.js"><link rel="prefetch" href="/assets/js/68.6212d2a9.js"><link rel="prefetch" href="/assets/js/69.0cd6b5c4.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/70.8e1f3dad.js"><link rel="prefetch" href="/assets/js/71.041fa5d5.js"><link rel="prefetch" href="/assets/js/72.7b626c12.js"><link rel="prefetch" href="/assets/js/73.78b38a87.js"><link rel="prefetch" href="/assets/js/74.6ec158a9.js"><link rel="prefetch" href="/assets/js/75.de5261fd.js"><link rel="prefetch" href="/assets/js/76.49878016.js"><link rel="prefetch" href="/assets/js/77.77eb5ec0.js"><link rel="prefetch" href="/assets/js/78.13279776.js"><link rel="prefetch" href="/assets/js/79.55cd4da6.js"><link rel="prefetch" href="/assets/js/80.2d4e5531.js"><link rel="prefetch" href="/assets/js/81.f00c64f4.js"><link rel="prefetch" href="/assets/js/82.af834374.js"><link rel="prefetch" href="/assets/js/83.42d97060.js"><link rel="prefetch" href="/assets/js/84.e6bc84a7.js"><link rel="prefetch" href="/assets/js/85.beeccec9.js"><link rel="prefetch" href="/assets/js/86.af675949.js"><link rel="prefetch" href="/assets/js/87.42f1b392.js"><link rel="prefetch" href="/assets/js/88.b5b8b77f.js"><link rel="prefetch" href="/assets/js/89.5892cf98.js"><link rel="prefetch" href="/assets/js/90.975b2533.js"><link rel="prefetch" href="/assets/js/91.64ccb26a.js"><link rel="prefetch" href="/assets/js/92.159aca5a.js"><link rel="prefetch" href="/assets/js/93.ca72cfb7.js"><link rel="prefetch" href="/assets/js/94.134a585d.js"><link rel="prefetch" href="/assets/js/95.83f34609.js"><link rel="prefetch" href="/assets/js/96.25383af1.js"><link rel="prefetch" href="/assets/js/97.404579a5.js"><link rel="prefetch" href="/assets/js/98.b15c1a8c.js"><link rel="prefetch" href="/assets/js/99.2757d9cd.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端收集</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/react-source/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/mdn/" class="nav-link router-link-active">
  MDN
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  JS进阶
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/deploy/" class="nav-link">
  工程化
</a></div><div class="nav-item"><a href="/qa/" class="nav-link">
  QA
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="链接" class="dropdown-title"><span class="title">链接</span> <span class="arrow down"></span></button> <button type="button" aria-label="链接" class="mobile-dropdown-title"><span class="title">链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://note.aduang.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  note
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/chnduang/cv-collect-blog.git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/react/" class="nav-link">
  React
</a></div><div class="nav-item"><a href="/react-source/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/mdn/" class="nav-link router-link-active">
  MDN
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  JS进阶
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/deploy/" class="nav-link">
  工程化
</a></div><div class="nav-item"><a href="/qa/" class="nav-link">
  QA
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="链接" class="dropdown-title"><span class="title">链接</span> <span class="arrow down"></span></button> <button type="button" aria-label="链接" class="mobile-dropdown-title"><span class="title">链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://note.aduang.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  note
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/chnduang/cv-collect-blog.git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/mdn/" aria-current="page" class="sidebar-link">目录</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/mdn/1-advanced" class="sidebar-heading clickable"><span>advanced</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mdn/1-this解析" class="sidebar-heading clickable"><span>this解析</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mdn/2-new的过程" class="sidebar-heading clickable"><span>new的过程</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mdn/2-promise" class="sidebar-heading clickable router-link-active open"><span>promise</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/mdn/2-promise/" aria-current="page" class="sidebar-link">目录</a></li><li><a href="/mdn/2-promise/19道promise面试题.html" class="sidebar-link">搜尽全网，整理了19道promise 面试题，你能做对几个？</a></li><li><a href="/mdn/2-promise/Promise.html" class="sidebar-link">Promise</a></li><li><a href="/mdn/2-promise/Promise面试实战指北.html" class="sidebar-link">Promise面试实战指北</a></li><li><a href="/mdn/2-promise/c.html" class="sidebar-link">面试官问：Promise.all 使用、原理实现及错误处理</a></li><li><a href="/mdn/2-promise/基于把原生ajax封装为Promise形式.html" class="sidebar-link">基于把原生ajax封装为Promise形式。</a></li><li><a href="/mdn/2-promise/实现自己promise.html" class="active sidebar-link">两天时间，实现自己的 Promise</a></li><li><a href="/mdn/2-promise/异步循环打印.html" class="sidebar-link">实现异步循环打印</a></li><li><a href="/mdn/2-promise/最简实现Promise.html" class="sidebar-link">最简实现Promise-支持异步链式调用</a></li><li><a href="/mdn/2-promise/模拟实现.html" class="sidebar-link">基础版本</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mdn/2-原型" class="sidebar-heading clickable"><span>原型</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mdn/2-手写题" class="sidebar-heading clickable"><span>手写题</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mdn/3-advanced-function" class="sidebar-heading clickable"><span>advanced-function</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mdn/3-api" class="sidebar-heading clickable"><span>api</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mdn/3-作用域闭包" class="sidebar-heading clickable"><span>作用域闭包</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mdn/4-动画" class="sidebar-heading clickable"><span>动画</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/mdn/5-数组" class="sidebar-heading clickable"><span>数组</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="两天时间-实现自己的-promise"><a href="#两天时间-实现自己的-promise" class="header-anchor">#</a> 两天时间，实现自己的 Promise</h2> <blockquote><p><a href="https://mp.weixin.qq.com/s/-2vIKWRPzdXCZlPupw4XcA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/-2vIKWRPzdXCZlPupw4XcA<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="_01-目录"><a href="#_01-目录" class="header-anchor">#</a> 01. 目录</h2> <ul><li><strong>02.自下而上</strong>[1]</li> <li><strong>03.如何实现</strong>[2]</li> <li><strong>04.Promise/A+规范</strong>[3]</li> <li><strong>05.更多优化</strong>[4]</li> <li><strong>06.源码</strong>[5]</li> <li><strong>07.小结</strong>[6]</li> <li><strong>08.其他参考</strong>[7]</li></ul> <h2 id="_02-自下而上"><a href="#_02-自下而上" class="header-anchor">#</a> 02.自下而上</h2> <h3 id="_02-01-基本概念"><a href="#_02-01-基本概念" class="header-anchor">#</a> 02.01 基本概念</h3> <ul><li>首先我们来整理一些 <code>Promise</code> 基本的概念，包括私有状态，内部方法，静态方法等等。</li></ul> <h4 id="私有属性"><a href="#私有属性" class="header-anchor">#</a> 私有属性</h4> <ul><li><p>私有属性包括状态和值 <code>PromisState</code> <code>PromiseResult</code>，这些属性外部无法访问。</p></li> <li><p>状态属性有以下三种：</p></li> <li><ul><li><code>pending</code> 初始化状态</li> <li><code>fulfilled</code> 兑现(完成)</li> <li><code>rejected</code> 拒绝</li></ul></li> <li><p>值属性，由 <code>resolve</code> 或 <code>reject</code> 处理来决定。</p></li></ul> <h4 id="实例方法"><a href="#实例方法" class="header-anchor">#</a> 实例方法</h4> <ul><li><strong><code>then</code></strong>[8]</li> <li><strong><code>catch</code></strong>[9]</li> <li><strong><code>finally</code></strong>[10]</li></ul> <h4 id="静态方法"><a href="#静态方法" class="header-anchor">#</a> 静态方法</h4> <ul><li><strong><code>Promise.reject</code></strong>[11]</li> <li><strong><code>Promise.resolve</code></strong>[12]</li> <li><strong><code>Promise.race</code></strong>[13]</li> <li><strong><code>Promise.all</code></strong>[14]</li> <li><strong><code>Promise.allSettled</code></strong>[15]</li> <li><strong><code>Promise.any</code></strong>[16]</li></ul> <h2 id="_03-如何实现"><a href="#_03-如何实现" class="header-anchor">#</a> 03.如何实现</h2> <h3 id="_03-01-基础类"><a href="#_03-01-基础类" class="header-anchor">#</a> 03.01 基础类</h3> <ul><li><p>在罗列所有的状态和方法之后，我们首先来实现一个最基础的 <code>Promise</code> 类。</p></li> <li><p>最基础的类，包括以下核心几点：</p> <div class="language- extra-class"><pre class="language-text"><code>/**
 * Promise 内部状态的枚举
 */
enum PROMISE_STATES {
  PENDING = 'pending',
  FULFILLED = 'fulfilled',
  REJECTED = 'rejected'
}

type PromiseStates = PROMISE_STATES.PENDING | PROMISE_STATES.FULFILLED | PROMISE_STATES.REJECTED;

export const isFunction = (fn: any):boolean =&gt; typeof fn === 'function';
export const isObject = (obj: any):boolean =&gt; typeof obj === 'object';

class PromiseLike {
  protected PromiseState: PromiseStates;
  protected PromiseResult: any;

constructor(executor) {
  this.PromiseState = PROMISE_STATES.PENDING;
  this.PromiseResult = undefined;

  executor(this._resolve, this._reject)
}

_resolve = (value?: any) =&gt; {
  if (this.PromiseState !== PROMISE_STATES.PENDING) {
    return;
  }
  this.PromiseState = PROMISE_STATES.FULFILLED;
  this.PromiseResult = value;
}

_reject = (value?: any) =&gt; {
  if (this.PromiseState !== PROMISE_STATES.PENDING) {
    return;
  }
  this.PromiseState = PROMISE_STATES.REJECTED;
  this.PromiseResult = value;
}
}
复制代码
</code></pre></div></li> <li><ul><li>拥有私有状态，也有着能够改变私有状态的私有方法。</li> <li>同时接收一个执行器函数作为参数，执行器函数内部则是预先定义好的私有方法。</li> <li>私有状态一旦改变（兑现或拒绝）后不可逆。</li></ul></li></ul> <h4 id="resolve-和-reject"><a href="#resolve-和-reject" class="header-anchor">#</a> resolve 和 reject</h4> <ul><li><p>上述代码比较好理解， 我们定义了状态，定义了执行器函数以及相关的两个参数，这两个参数对应的方法分别修改了对应的状态。</p></li> <li><p>但是差点忘了， <code>Promise</code> 是异步的，意味着这两个函数处理也应当是异步的；这里可以使用 <code>setTimeout</code> 来模拟异步进程。这部分还可以优化，后面我们会提到。</p> <div class="language- extra-class"><pre class="language-text"><code>class PromiseLike {
/**
  * 使状态变更为 fulfilled
  * 调用注册的事件，注意调用后进行清除
  * @param value
  * @returns
  */
_resolve = (value?: any) =&gt; {
  const resolveCb = () =&gt; {
    if (this.PromiseState !== PROMISE_STATES.PENDING) {
      return;
    }

    this.PromiseState = FULFILLED;
    this.PromiseResult = value;
  }

  // 使任务变成异步的
  setTimeout(resolveCb, 0);
}

/**
 * 使状态变更为 rejected
  * @param value
  */
_reject = (value?: any) =&gt; {
  const rejectCb = () =&gt; {
    if (this.PromiseState !== PROMISE_STATES.PENDING) {
      return;
    }

    this.PromiseState = REJECTED;
    this.PromiseResult = value;
  }

  setTimeout(rejectCb, 0);
}
}
复制代码
</code></pre></div></li> <li><p>我们可以接着实现相关的静态方法，因为它们所做的事很简单，就是修改当前的内部状态，于是完全可以直接调用当前类实例化来处理。</p></li> <li><p>重复代码不再罗列，下面是新增的静态方法：</p> <div class="language- extra-class"><pre class="language-text"><code>class PromiseLike {
// ...sth
static resolve(value?: any) {
  return new PromiseLike((resolve) =&gt; resolve(value));
}

static reject(value?: any) {
  return new PromiseLike((resolve, reject) =&gt; reject(value));
}
}
复制代码
</code></pre></div></li> <li><p>一个简单的基础类就这样完成了。不过先不要着急，当前的实现显然有许多要完善的地方，甚至也许有错误，让我们进一步来梳理。</p></li></ul> <h3 id="_03-02-原型方法"><a href="#_03-02-原型方法" class="header-anchor">#</a> 03.02 原型方法</h3> <h4 id="promise-prototype-then"><a href="#promise-prototype-then" class="header-anchor">#</a> <code>Promise.prototype.then</code></h4> <ul><li><p>相信对 <code>Promise</code> 有所了解的都知道 <code>Promise</code> 的 <code>then</code> 方法以及它的链式调用。本质上，**它是对 <code>Thenable</code> 接口的具体实现。**这句话很重要，后面会用到。</p></li> <li><p>让我们先来回顾一下 <code>then</code> 的用法：</p> <div class="language- extra-class"><pre class="language-text"><code>Promise.resolve(29).then(function fulfilled(res) {
console.info(res);
return res;
}, function rejected(err) {
console.error(err);
});
复制代码
</code></pre></div></li> <li><p><code>then</code> 方法接收两个参数，分别用来处理 <code>resolve</code> 和 <code>reject</code> 的结果，称之为完成回调和拒绝回调。默认情况下，同时注册这两个回调方法，一次只可能会调用到其中一个。即使在前一个函数中抛出了异常，第二个异常捕获函数也无法立即捕获。</p></li> <li><ul><li>完成回调，接收先前 <code>promise</code> 的 <code>resolve</code> 值作为默认参数，处理对应数据，并返回一个值，作为下一个 <code>then</code> 内部函数调用的默认参数。</li> <li>让我们再仔细想想， <code>then</code> 注册事件的调用次数是否和注册次数相同？是的。假如使用 <code>then</code> 注册了多个回调函数，则它们会依次执行。这意味着我们得在原先的基础上加上相应的事件队列。</li> <li>另外别忘了， <code>then</code> 方法支持<strong>链式调用</strong>，我们这里先使用 <code>return this</code> 的方式来简单实现。</li></ul></li> <li><p>现在我们对上面的基础类进行改进和修复。</p> <div class="language- extra-class"><pre class="language-text"><code>export interface ICallbackFn {
(value?: any): any;
}

type CallbackParams = ICallbackFn | null;

export interface IExecutorFn {
(resolve: ICallbackFn,  reject: ICallbackFn): any;
}

class PromiseLike {
protected PromiseState: PromiseStates;
protected PromiseResult: any;

resolveCallbackQueues: Array&lt;ICallbackFn&gt;;
rejectCallbackQueues: Array&lt;ICallbackFn&gt;;

constructor(executor: IExecutorFn) {
  if (!isFunction(executor)) {
    throw new Error('Promise resolver undefined is not a function');
  }
  this.PromiseState = PENDING;
  this.PromiseResult = undefined;

  // 分别用于两个注册事件保存的数组
  this.resolveCallbackQueues = [];
  this.rejectCallbackQueues = [];

  executor(this._resolve, this._reject);
}

/**
 * 使状态变更为 fulfilled
* 调用注册的事件，注意调用后进行清除
* @param value
* @returns
*/
_resolve = (value: any) =&gt; {
  const resolveCb = () =&gt; {
    if (this.PromiseState !== PROMISE_STATES.PENDING) {
      return;
    }
    while (this.resolveCallbackQueues.length) {
      const fn = this.resolveCallbackQueues.shift();
      fn &amp;&amp; fn(value);
    }
    this.PromiseState = FULFILLED;
    this.PromiseResult = value;
  }

  // 使任务变成异步的
  setTimeout(resolveCb, 0);
}

/**
 * 使状态变更为 rejected
* @param value
*/
_reject = (value: any) =&gt; {
  const rejectCb = () =&gt; {
    if (this.PromiseState !== PROMISE_STATES.PENDING) {
      return;
    }
    while (this.rejectCallbackQueues.length) {
      const fn = this.rejectCallbackQueues.shift();
      fn &amp;&amp; fn(value);
    }
    this.PromiseState = REJECTED;
    this.PromiseResult = value;
  }

  setTimeout(rejectCb, 0);
}

/**
 * 根据当前不同状态来执行对应逻辑
* 如果在默认状态就是注册对应事件
* 如果状态变化则是执行对应事件
* @param onFulfilled
* @param onRejected
* @returns
*/
then = (onFulfilled, onRejected) =&gt; {
  switch (this.PromiseState) {
    case PENDING:
      isFunction(onFulfilled) &amp;&amp; this.resolveCallbackQueues.push(onFulfilled);
      isFunction(onRejected) &amp;&amp; this.rejectCallbackQueues.push(onRejected);
    case FULFILLED:
      isFunction(onFulfilled) &amp;&amp; onFulfilled(this.PromiseResult);
      break;
    case REJECTED:
      isFunction(onRejected) &amp;&amp; onRejected(this.PromiseResult);
      break;
  }
  return this;
}
}
复制代码
</code></pre></div></li> <li><ul><li>定义两个数组，分别用来保存完成回调和拒绝回调。</li> <li>下面罗列核心代码：</li></ul></li> <li><p>我们丰富了 <code>then</code> 方法。但是你我都知道，<code>return this</code> 看起来并不太可靠。</p></li> <li><p>让我们来回顾一点，<strong><code>Promise</code> 的私有状态一旦改变后不可逆</strong>。如果在这个 <code>then</code> 方法里抛出异常， <code>promise</code> 显然会变成拒绝状态，而同一实例的状态在改变后是不能够再次修改的。所以， <code>then</code> 的链式调用本质上是每次都会生成一个新的实例。</p></li> <li><p>也许再贴一个使用 <code>then</code> 的例子会让我们有一些启发。</p> <div class="language- extra-class"><pre class="language-text"><code>const p = Promise.resolve(123);
const p1 = p.then();
const p2 = p1.then((val) =&gt; val + 123))
const p3 = p2.then(console.info));
const p4 = p3.then(() =&gt; {
throw new Error('Oops!');
});
// 分别打印 p1 p2 p3 p4
// Promise {&lt;fulfilled&gt;: 123}
// Promise {&lt;fulfilled&gt;: 246}
// Promise {&lt;fulfilled&gt;: undefined}
// Promise {&lt;rejected&gt;: Error: Oops!
复制代码
</code></pre></div></li> <li><p>这段代码的输出，有助于让我们进一步理解 <code>then</code> 内部所做的事。</p></li> <li><ul><li>p1: 在没有传入回调函数的时候，它仅仅是将值传递，也就是内部会初始化一个默认的处理函数，这个处理函数只会乖乖地传递值。</li> <li>p2: 存在完成回调时，可以获取值并进行处理，这个新的值通过<strong>返回的形式</strong>继续往后传递。</li> <li>p3: 如果传入完成回调函数，但没有显式返回值，则最终的 <code>promise</code> 的值是 <code>undefined</code>.</li> <li>p4: <code>promise</code> 状态已经变更成 <code>rejected</code>, 意味着是新的 <code>promise</code>. 符合我们的预期。</li></ul></li> <li><p>带着上述理解，我们来改进 <code>then</code> 方法。</p></li> <li><p>首先，需要处理参数异常的情况，也就是传入参数不是函数，或者未传的情况，就给定默认处理函数。</p> <div class="language- extra-class"><pre class="language-text"><code>then = (onFulfilled?: CallbackParams, onRejected?: CallbackParams) =&gt; {
</code></pre></div></li> <li><ul><li>完成回调负责传递参数。</li> <li>拒绝回调负责抛出异常。</li></ul></li></ul> <p>// 默认处理！！！onFulfilled = isFunction(onFulfilled) ? onFulfilled : value =&gt; value; onRejected = isFunction(onRejected) ? onRejected : err =&gt; { throw err }; } 复制代码</p> <div class="language- extra-class"><pre class="language-text"><code>- 我们把这两个兼容处理放在函数内的顶部，这样有助于理解，也可以简化后续的逻辑。

- 下面是具体的内容，其中核心改动已注释说明。

```ts
class PromiseLike {
/**
 * 根据当前不同状态来执行对应逻辑
* 如果在默认状态就是注册对应事件
* 如果状态变化则是执行对应事件
* @param onFulfilled
* @param onRejected
* @returns
*/
then = (onFulfilled: CallbackParams, onRejected: CallbackParams) =&gt; {
  // 默认处理！！！
  onFulfilled = isFunction(onFulfilled) ? onFulfilled : value =&gt; value;
  onRejected = isFunction(onRejected) ? onRejected : err =&gt; { throw err };
  return new PromiseLike((resolve, reject) =&gt; {
    /**
     * 封装完成回调函数
    * @param val
    */
    const handleFulfilled = (val: any) =&gt; {
      try {
        const res = onFulfilled(val);
        resolve(res);
      } catch (error) {
        // 如果当前执行逻辑内发生异常，则抛出异常
        reject(error);
      }
    };

    /**
     * 封装错误回调函数
    * @param val
    */
    const handleRejected = (val: any) =&gt; {
      try {
        const res = onRejected(val);
        reject(res);
      } catch (error) {
        reject(error);
      }
    }

    switch (this.PromiseState) {
      case PROMISE_STATES.PENDING:
        this.resolveCallbackQueues.push(handleFulfilled);
        this.rejectCallbackQueues.push(handleRejected);
        break;
      case PROMISE_STATES.FULFILLED:
        handleFulfilled(this.PromiseResult);
        break;
      case PROMISE_STATES.REJECTED:
        handleRejected(this.PromiseResult);
        break;
    }
  });
}
}
复制代码
</code></pre></div><ul><li><p>这个 <code>then</code> 方法的处理已经接近完善，不过在 <code>Promise</code> 里有一点容易被人遗忘。</p> <div class="language- extra-class"><pre class="language-text"><code>Promise.resolve(41) === Promise.resolve(Promise.resolve(41)); // false
复制代码
</code></pre></div></li> <li><ul><li>在 <code>Promise</code> 中处理 <code>Promise</code>，内部处理会将其展开来获取其中的值。</li> <li>下面这个例子出来你就理解了。</li></ul></li> <li><p>不好意思，走错片场。js 中每个单独定义的引用类型都是不相等的。</p> <div class="language- extra-class"><pre class="language-text"><code>const p = Promise.resolve(41);
Promise.resolve(p) === p; // true
复制代码
</code></pre></div></li> <li><ul><li>再来一次。</li></ul></li> <li><p>没错，如果我们给 <code>promise</code> 一个 <code>promise</code> 值，内部机制会将其展开。这个过程是递归的，这里我们先不展开探讨，但记住有这样的场景需要处理。</p></li> <li><p>可以先定义一个静态方法判断是否是 <code>Promise</code> 实例，方便后续的判断。</p> <div class="language- extra-class"><pre class="language-text"><code>class PromiseLike {
/**
 * 判断是否是当前类的实例
* @param promise
* @returns
*/
static is(promise: PromiseType) {
  return promise instanceof PromiseLike;
}
}
复制代码
</code></pre></div></li> <li><p>有了这个方法，我们可以进一步完善上面的 <code>then</code> 方法。注意观察其中的变化，有注释说明。</p></li> <li><p>为方便阅读，只展示核心方法（只有这里改动）。</p> <div class="language- extra-class"><pre class="language-text"><code>/**
</code></pre></div></li> <li><p>封装完成回调函数</p></li> <li><p>@param val */ const handleFulfilled = (val) =&gt; { try { const res = onFulfilled(val); if (PromiseLike.is(res)) { // 如果参数是 Promise 实例，直接可以把 promise 实例进行传递 res.then(resolve, reject); } else  { resolve(res); } } catch (error) { // 如果当前执行逻辑内发生异常，则抛出异常 reject(error); } }; 复制代码</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>#### `Promise.prototype.catch`

- 在实现 `then` 方法之后，其实 `catch` 的实现是你想象不到的简单。

- 因为本质上 `catch` 方法是 `then` 第二个参数也就是错误回调函数的语法糖。照着这个理解，实现起来就比较容易。

```ts
class PromiseLike {
/**
 * 错误处理
* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch
* @param rejectedCb
* @returns
*/
catch = (rejectedCb: CallbackParams) =&gt; {
  return this.then(null, rejectedCb);
}
}
复制代码
</code></pre></div><h4 id="promise-prototype-finally"><a href="#promise-prototype-finally" class="header-anchor">#</a> <code>Promise.prototype.finally</code></h4> <ul><li><p>实现 <code>finally</code> 需要我们理解几个点。</p></li> <li><ul><li>前面的状态只要不是 <code>pending</code>, 则一定会进入执行。</li> <li>类似于 <code>then</code>, 它可以注册多个回调，每个回调函数会依次执行。</li> <li>回调函数内无法获取内部值。</li> <li>除非在回调函数内抛出异常会把状态变成 <code>rejected</code>，否则它所做的仅仅是把状态和值传递。</li></ul></li> <li><p>了解上述几点之后，我们可以复用 <code>then</code> 方法，并自定义回调函数传入来实现。</p> <div class="language- extra-class"><pre class="language-text"><code>class PromiseLike {
/**
 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally
* @param finallyCb
* @returns
*/
finally = (finallyCb: CallbackParams) =&gt; {
  return this.then(
    // 完成回调时，执行注册函数，并且将原来的值传递下去
    // 封装 Promise 类，再调用 then 方法传递
    val =&gt; PromiseLike.resolve(finallyCb &amp;&amp; finallyCb()).then(() =&gt; val),
    // 异常回调时，执行注册函数，并且抛出异常
    err =&gt; PromiseLike.resolve(finallyCb &amp;&amp; finallyCb()).then(() =&gt; { throw err })
  );
}
}
复制代码
</code></pre></div></li> <li><p>写到这里，几个核心的原型方法我们就实现完毕了。</p></li> <li><p>心急的伙伴可以直接实例化一个对象来尝试，不过 <code>Promise</code> 当然还不止于此，接下来我们来实现对应的静态方法。</p></li></ul> <h3 id="_03-03-静态方法"><a href="#_03-03-静态方法" class="header-anchor">#</a> 03.03 静态方法</h3> <ul><li>前面已经实现了一个自定义的 <code>Promise.is</code> 方法来判断实例。这个工具类函数简单实用，可以留着。</li> <li>还有两个快速实例化 <code>Promise</code> 类的方法我们也进行了实现：<code>Promise.resolve</code> 和 <code>Promise.reject</code>. 下面来做一点改进。</li></ul> <h4 id="promise-resolve"><a href="#promise-resolve" class="header-anchor">#</a> <code>Promise.resolve</code></h4> <ul><li><p>既然我们定义好了 <code>Promise.is</code> 方法，加上对 <code>Promise</code> 的理解进一步加深，知道了如果传入的已经是 <code>Promise</code> 实例，则不必再进行处理。所以这个方法需要做一点兼容处理。</p> <div class="language- extra-class"><pre class="language-text"><code>class PromiseLike {
/**
 * 直接实例化 proimse
* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve
* @param value
* @returns
*/
static resolve(value?: any) {
  if (PromiseLike.is(value)) {
    return value;
  }
  return new PromiseLike((resolve) =&gt; resolve(value));
}
}
复制代码
</code></pre></div></li> <li><p>现在我们可以尝试实现 <code>Promise</code> 提供的剩下两个类方法 <code>Promise.all</code>, <code>Promise.race</code>.</p></li></ul> <h4 id="promise-all"><a href="#promise-all" class="header-anchor">#</a> <code>Promise.all</code></h4> <ul><li><p>该方法是接收一个由 <code>Promise</code> 实例组成的数组，并返回 <code>Promise</code> 实例，其值是所有 <code>Promise</code> 实例的 <code>resolve</code> 的值组成的数组。</p></li> <li><ul><li>当其中任意一个 <code>Promise</code> 有 <code>reject</code> 的值时，<code>Promise.all</code> 会返回最先 <code>rejected</code>的值。</li> <li>等到所有 <code>Promise</code> <code>resolve</code> 之后，<code>Promise</code>.all 才会返回结果。</li> <li><code>Promise.all</code> 也是支持链式调用的。</li></ul></li> <li><p>大白话也许有些晦涩，我们直接看案例。</p> <div class="language- extra-class"><pre class="language-text"><code>Promise.all([Promise.resolve(1), Promise.reject(2)]); // Promise {&lt;rejected&gt;: 2}
Promise.all([Promise.resolve(1), Promise.resolve(2)]); // Promise {&lt;fulfilled&gt;: Array(2)} [1, 2]
Promise.all([]); // Promise {&lt;fulfilled&gt;: Array(2)}
复制代码
</code></pre></div></li> <li><p>其中，第三个表达式的结果对理解 <code>Promise.race</code> 和 <code>Promise.all</code> 的区别很重要。这点后面会谈。除此之外，结果是显而易见的。</p></li> <li><p><code>Promise.all</code> 返回的结果是传入数组的参数的顺序，也可以理解为顺序执行，并填入对应的位置。基于这几点，要实现它就有思路了。</p> <div class="language- extra-class"><pre class="language-text"><code>class PromiseLike {
/**
 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all
* @param promises 严格意义上来说，参数是可迭代对象，为了简化实现这里统一成数组
* @returns
*/
static all(promises: Array&lt;ICallbackFn&gt;) {
  // 支持链式调用
  return new PromiseLike((resolve, reject) =&gt; {
    const len = promises.length;
    let resolvedPromisesCount = 0;
    let resolvedPromisesResult = &lt;any&gt;[];
    for (let i = 0; i &lt; len; i++) {
      const currentPromise = promises[i];
      // 如果不是 Promise 实例，则需要包装一份；
      // 但因为直接包装 Promise 类的效果是幂等的，所以这里不需要判断，直接处理即可
      PromiseLike.resolve(currentPromise)
      .then((res: any) =&gt; {
        resolvedPromisesCount++;
        resolvedPromisesResult[i] = res;
        // 当所有值都 resolve 之后， 返回对应数组
        if (resolvedPromisesCount === len) {
          resolve(resolvedPromisesResult);
        }
      })
      // 如果有任意一个异常，则直接推出
      .catch((err: any) =&gt; {
        reject(err);
      });
    }
  });
}
}
复制代码
</code></pre></div></li> <li><ul><li>顺序执行所有 <code>Promise</code>，并把结果保存到数组的对应位置，同时统计已执行的数量；当该数量等同于传入的数组长度时，返回由结果组成的数组。</li></ul></li> <li><p>如同在方法注释里说明的一样，其实 <code>Promise.all</code> 和 <code>Promise.race</code> 方法接收的参数都是可迭代对象，并不仅仅是数组。这里为了方便实现，使用数组替代。可迭代对象不在这篇文章的核心讨论范围之内，感兴趣的可以点进上面的链接继续了解。</p></li></ul> <h4 id="promise-race"><a href="#promise-race" class="header-anchor">#</a> <code>Promise.race</code></h4> <ul><li><p><code>Promise.race</code> 和 <code>Promise.all</code> 有些相似，至少就参数而言，都接收可迭代对象作为参数，也可以链式调用，意味着它也返回一个新的 <code>Promise</code> 实例。</p></li> <li><p>不同的是，<code>Promise.race</code> 将会返回第一个 <code>Promise.resolve</code> 的值，或是第一个 reject 的值，而且这个值并不是数组。</p></li> <li><p>了解到这两点之后，实现起来就有清晰的思路了。</p> <div class="language- extra-class"><pre class="language-text"><code>class PromiseLike {
/**
 * https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race
* @param promises
* @returns
*/
static race(promises: Array&lt;ICallbackFn&gt;) {
  return new PromiseLike((resolve, reject) =&gt; {
    for (let i = 0; i &lt; promises.length; i++) {
      const currentPromise = promises[i];
      PromiseLike.resolve(currentPromise)
        .then((res: any) =&gt; {
          resolve(res);
        })
        .catch((err: any) =&gt; {
          reject(err);
        });
    }
  });
}
}
复制代码
</code></pre></div></li> <li><ul><li>遍历顺序执行所有 Promise 并取出第一个 resolve 的值。</li></ul></li> <li><p>再运行这样一段代码，得到的结果应该并不会让你意外。</p> <div class="language- extra-class"><pre class="language-text"><code>Promise.race([]); // Promise {&lt;pending&gt;} 与 Promise.all 的结果不同
复制代码
</code></pre></div></li> <li><p>至此，目前已广泛兼容的两个核心方法我们都已经实现了。这是不是意味着可以愉快的玩耍了呢，当然可以。不过，既然都走到这一步了，我们顺带可以实现更多的 <code>Promise</code> 方法，一来锻炼动手能力，二来证明学以致用。</p></li></ul> <h3 id="_03-04-其他静态方法"><a href="#_03-04-其他静态方法" class="header-anchor">#</a> 03.04 其他静态方法</h3> <h4 id="promise-allsettled"><a href="#promise-allsettled" class="header-anchor">#</a> <code>Promise.allSettled</code></h4> <ul><li><p>这个方法和 <code>Promise.all</code> 非常相似，执行所有的 <code>Promise</code> 实例并返回所有的结果，不论结果如何，都在返回的数组里塞回一个对象。</p></li> <li><ul><li>每个对象只有两个属性 <code>status</code> 和 <code>value</code> 或 <code>reason</code>；如果当前 <code>proimse</code> 是 <code>fulfilled</code> 则属性是 <code>status</code> 和 <code>value</code>, 如果当前是 <code>rejected</code> 则属性是 <code>status</code> 和 <code>reason</code>.</li></ul></li> <li><p>对 <code>Promise.all</code> 稍加改动就可以实现。</p> <div class="language- extra-class"><pre class="language-text"><code>/**
</code></pre></div></li> <li><ul><li>判断计数的逻辑在两个回调函数中都进行，并且对返回值加一层包装。</li></ul></li> <li><p>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled</p></li> <li><p>@param promises 严格意义上来说，参数是可迭代对象，为了简化实现这里统一成数组</p></li> <li><p>@returns */ static allSettled(promises: Array) { // 支持链式调用 return new PromiseLike((resolve, reject) =&gt; { const len = promises.length; const startTime = Date.now(); let resolvedPromisesCount = 0; let resolvedPromisesResult =[];</p> <p>for (let i = 0; i &lt; len; i++) { const currentPromise = promises[i]; // 如果不是 Promise 实例，则需要包装一份；// 但因为直接包装 Promise 类的效果是幂等的，所以这里不需要判断，直接处理即可 PromiseLike.resolve(currentPromise) .then((res: any) =&gt; { resolvedPromisesCount++; resolvedPromisesResult[i] = { status: PROMISE_STATES.FULFILLED, value: res }; // 当所有 promises 完成后，返回数组；多封装了一个属性用于显示执行时间 if (resolvedPromisesCount === len) { resolvedPromisesResult.duringTime = Date.now() - startTime + 'ms'; resolve(resolvedPromisesResult); } }) // 如果有任意一个异常，则直接推出 .catch((err: any) =&gt; { resolvedPromisesCount++; resolvedPromisesResult[i] = { status: PROMISE_STATES.REJECTED, reason: err }; if (resolvedPromisesCount === len) { resolvedPromisesResult.duringTime = Date.now() - startTime + 'ms'; resolve(resolvedPromisesResult); } }); } }); } 复制代码</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>#### `Promise.any`

- 这是今年\(2021\)刚刚落定草案的新 API。定义和 `Promise.race` 很相似，接收可迭代对象作为参数，可以链式调用。

- 不同的是，它会返回第一个落定的，也就是 `resolve` 的值；如果传入的 `promise` 全都都进入拒绝状态，则它会等到所有拒绝状态都完成后，再返回一个由拒绝错误组成的对象。这个对象是新定义的类型 [AggregateError](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FAggregateError &quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AggregateError&quot;)，这里暂且先不展开，直接使用它。

- 从定义上来看，它和 `Promise.race` 相似，不过从实现上观察，却和 `Promise.all` 更加相似。

 -    只需要把计算数量的逻辑搬到错误回调中，并将其返回错误对象即可。

```javascript
class PromiseLike {
/**
 * 2021 年刚纳入规范的 any
* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any
* @param promises
* @returns
*/
static any(promises: Array&lt;ICallbackFn&gt;) {
  return new PromiseLike((resolve, reject) =&gt; {
    const len = promises.length;
    let rejectedPromisesCount = 0;
    let rejectedPromisesResult = &lt;any&gt;[];
    for (let i = 0; i &lt; promises.length; i++) {
      const currentPromise = promises[i];
      PromiseLike.resolve(currentPromise)
        .then((res: any) =&gt; {
          resolve(res);
        })
        .catch((err: any) =&gt; {
          rejectedPromisesCount++;
          rejectedPromisesResult[i] = err;
          if (rejectedPromisesCount === len) {
            // 如果浏览器支持，则直接抛出这个新对象，否则则直接抛出异常
            if (isFunction(AggregateError)) {
              throw new AggregateError(rejectedPromisesResult, 'All promises were rejected');
            } else {
              throw (rejectedPromisesResult);
            }
          }
        });
    }
  })
}
}
复制代码
</code></pre></div><h2 id="_04-promise-a-规范"><a href="#_04-promise-a-规范" class="header-anchor">#</a> 04.Promise/A+规范</h2> <h3 id="_04-01-promises-aplus-tests-验证"><a href="#_04-01-promises-aplus-tests-验证" class="header-anchor">#</a> 04.01 promises-aplus-tests 验证</h3> <ul><li><p>这个库 <strong>promises-aplus-tests</strong>[17] 可以用来验证我们实现的 <code>Promise</code> 是否遵循 <strong>Promise/A+规范</strong>[18] 。</p></li> <li><p>使用方式比较简单，注入一个方法即可，这个方法返回的对象包含 <code>Promise/resolve/reject</code>.</p></li> <li><p>由于我们使用类的方式编写，所以直接新增一个静态函数即可。</p> <div class="language- extra-class"><pre class="language-text"><code>class PromiseLike {
/**
 * 三方库验证
* @returns
*/
static deferred() {
  let defer: any = {};
  defer.promise = new PromiseLike((resolve, reject) =&gt; {
    defer.resolve = resolve;
    defer.reject = reject;
  });
  return defer;
}
}
复制代码
</code></pre></div></li> <li><p>需要注意的是，要用 <code>commonjs</code> 规范的方式来导出，否则会出现报错。</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = PromiseLike;
复制代码
</code></pre></div></li> <li><p>运行 <code>npx promises-aplus-tests 目录名</code> 进行验证。</p></li></ul> <h3 id="_04-02-并不完美-兼容修复"><a href="#_04-02-并不完美-兼容修复" class="header-anchor">#</a> 04.02 并不完美（兼容修复）</h3> <ul><li>运行结果显示，有部分 case 没有通过。糟透了！下面一一提取。</li></ul> <h4 id="chaining-cycle-detected-for-promise"><a href="#chaining-cycle-detected-for-promise" class="header-anchor">#</a> 'Chaining cycle detected for promise'</h4> <ul><li><p>这个异常显示，我们不能在 <code>promise</code> 中使用自身，否则会造成死循环。</p></li> <li><p>举个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>const p = Promise.resolve(1).then(() =&gt; p);
复制代码
</code></pre></div></li> <li><p>运行这段代码，就会得到上述报错。</p></li> <li><p>解决办法并不难，定义变量来保存 <code>then</code> 函数的返回值，同时在内部方法返回的位置进行兼容处理，如果相等就抛出异常。</p> <div class="language- extra-class"><pre class="language-text"><code>const res = onFulfilled(val);
// 返回的 promise 不可以是当前的 promise 否则会造成死循环
if (newPromise === res) {
 throw new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;');
}
复制代码
</code></pre></div></li></ul> <h4 id="_2-3-3-otherwise-if-x-is-an-object-or-function"><a href="#_2-3-3-otherwise-if-x-is-an-object-or-function" class="header-anchor">#</a> <code>2.3.3: Otherwise, if</code> x <code>is an object or function</code></h4> <ul><li><p>再次执行，发现 <code>Promise</code> 规范对传入参数是对象和函数类型也有着特殊的处理。我们并没有处理，所以出现了上述报错。<strong>规范里</strong>[19] 有所定义，我们可以简单理解为如果传入的参数是 <code>Thenable</code> 的，则需要调用其中的 <code>then</code> 方法，也就是将其展开调用。上文中自己有提到，终究是逃不过。</p></li> <li><p>之前我们仅仅对 <code>Promise</code> 的实例进行了特殊处理，现在意识到还需要处理 <code>Thenable</code> 接口的对象。但因为 <code>Promise</code> 实例本身就是实现 <code>Thenable</code> 接口的特殊对象。(<code>typeof Promise.resolve(1); // object</code>)，所以实现了对 <code>Thenable</code> 接口的处理，自然也能涵盖原有的逻辑。</p></li> <li><p>新定义一个单独的方法来实现，以提高可读性。</p> <div class="language- extra-class"><pre class="language-text"><code>/**
</code></pre></div></li> <li><ul><li>这个函数有些复杂，但每一条逻辑都可以在规范里追溯。</li></ul></li> <li><p>该实现遵循 Promise/A+ 规范</p></li> <li><p>https://github.com/promises-aplus/promises-spec</p></li> <li><p>@param promise</p></li> <li><p>@param x</p></li> <li><p>@param resolve</p></li> <li><p>@param reject</p></li> <li><p>@returns */ const resolvePromise = (promise: any, x: any, resolve: ICallbackFn, reject: ICallbackFn) =&gt;// 返回的 promise 不可以是当前的 promise 否则会造成死循环 if (newPromise === x) { reject(new TypeError('Chaining cycle detected for promise #')); } // 对可能是 thenable 接口实现的对象判断 if (isObject(x)| isFunction(x)) { if (x === null) { return resolve(x);let thenCb; try { thenCb = x.then; } catch (error) { return reject(error); }</p> <p>// 如果是 thenable 的对象，则调用其 then 方法 // 这一步涵盖了 Promise 实例的可能性 if (isFunction(thenCb)) { let isCalled = false; try { thenCb.call( x, // 指向当前函数或对象 (y: any) =&gt; { // 如果 resolvePromise 和 rejectPromise 都可能被调用 // 则只需调用第一次（resolvePromise 或 rejectPromise），后续无需再执行 if (isCalled) return; isCalled = true; // 传入当前函数，以实现递归展开调用 resolvePromise(promise, y, resolve, reject); }, (r: any) =&gt; { // 对应前面任意的调用之后，就不再只需后续逻辑 if (isCalled) return; isCalled = true; reject(r); } ) } catch (error) { if (isCalled) return; reject(error); } } else { resolve(x); } } else { resolve(x); } } 复制代码</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>- 在原先处理数据的地方，换成 `resolvePromise` 函数就可以了。

- 这下是可算是完整通过测试了。

```shell
872 passing (14s)
复制代码
</code></pre></div><h2 id="_05-更多优化"><a href="#_05-更多优化" class="header-anchor">#</a> 05.更多优化</h2> <h3 id="_05-01-queuemicrosoft-20"><a href="#_05-01-queuemicrosoft-20" class="header-anchor">#</a> 05.01 queueMicrosoft[20]</h3> <ul><li>学习过程中，意外发现 <code>queueMicrosoft</code> 这个方法，用于将任务转换成微任务。我们知道 <code>setTimeout</code> 虽然可以实现异步的效果，但它属于宏任务，与 <code>Promise</code> 所属的微任务不符。所以可以用 <code>queueMicrosoft</code> 来替换。</li> <li>有关使用方式，可以<strong>查看这里</strong>[21]</li></ul> <h3 id="_05-02-typescript-完善"><a href="#_05-02-typescript-完善" class="header-anchor">#</a> 05.02 typescript 完善</h3> <ul><li><p>前面的例子里已经定义许多接口。这里举个例子完善一哈，更多详细内容可以查看下文的源码。</p> <div class="language- extra-class"><pre class="language-text"><code>export interface IPromiseType {
then: IExecutorFn;
catch: ICallbackFn;
finally: ICallbackFn;
}

class PromiseLike implements IPromiseType {}
复制代码
</code></pre></div></li> <li><p>由于自己的 typescript 实践仍在学习中，可能源码中还存在许多值得改进和优化的地方，可以在评论或 issue 中指出，合理的改进建议一定会采纳并实践。</p></li> <li><p>使用版本：<code>&quot;typescript&quot;: &quot;^4.3.5&quot;</code></p></li></ul> <h3 id="_05-03-花里胡哨的变种方法"><a href="#_05-03-花里胡哨的变种方法" class="header-anchor">#</a> 05.03 花里胡哨的变种方法</h3> <h4 id="promise-last"><a href="#promise-last" class="header-anchor">#</a> <code>Promise.last</code></h4> <ul><li><p>定义一个函数，返回最后一个完成的 <code>promise</code>, 并且可以选择是否需要 <code>rejected</code> 的 <code>promise</code>.</p> <div class="language- extra-class"><pre class="language-text"><code>/**
</code></pre></div></li> <li><p>返回最后一个完成的值，可以自行决定是否忽略异常</p></li> <li><p>如果不忽略，异常优先抛出</p></li> <li><p>如果忽略，返回完成值</p></li> <li><p>@param promises</p></li> <li><p>@param ignoreRejected</p></li> <li><p>@returns */ static last(promises: Array, ignoreRejected: boolean = false) { return new PromiseLike((resolve, reject) =&gt; { const len = promises.length; const startTime = Date.now(); let resolvedPromisesCount = 0;</p> <p>for (let i = 0; i &lt; len; i++) { const currentPromise = promises[i]; PromiseLike.resolve(currentPromise) .then((res: any) =&gt; { resolvedPromisesCount++; // 当所有 promises 完成后，返回最后一个值；封装一个属性用于显示执行时间 if (resolvedPromisesCount === len) { isObject(res) &amp;&amp; (res.duringTime = Date.now() - startTime + 'ms'); resolve(res); } }) // 如果有任意一个异常，则直接推出 .catch((err: any) =&gt; { if (ignoreRejected) { resolvedPromisesCount++; } else { reject(err) } }); } }); } 复制代码</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>- 还可以实现一个它的变种，即返回最后一个更新的值，不论是 `fulfilled` 或者 `rejected` 状态.源码有展示，这里不再赘述。

#### `Promise.wrap`

- 该方法可以将原来的普通异步请求包装成 `Promise` 实例，便于链式调用等。

- 假设有这样一个请求处理函数。

```ts
function fn(url, cb) {
ajax(url, cb);
}
复制代码
</code></pre></div><ul><li><p>想让它变成可以使用链式调用，使用方式见注释。</p> <div class="language- extra-class"><pre class="language-text"><code>/**
</code></pre></div></li> <li><p>把不是 promise 实例的函数包装成 promise 实例</p></li> <li><p>例如 ajax 请求</p></li> <li><p>const request = Promise.wrap(ajax);</p></li> <li><p>request.then(callback);</p></li> <li><p>@param fn</p></li> <li><p>@returns */ static wrap(fn: any) { if (!isFunction(fn)) { return fn; } return function () { const args: any[] = Array.prototype.slice.call(arguments); return new PromiseLike((resolve) =&gt; { fn.apply(null, args.concat(function (res: any, err: any) { res &amp;&amp; resolve(res); err &amp;&amp; resolve(err); })); }) } } 复制代码</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>#### `Promise.sequence`

- 链式调用的能力可以结合数组的 `reduce` 完成串行操作，把函数传入组合成新的函数。

 -    这里的参数不涉及 `Promise` 实例，使用链式调用来实现。

```ts
/**
* 返回一个函数来执行
* @param fns
* @returns
*/
static sequence(fns: Array&lt;ICallbackFn&gt;) {
return (x: number) =&gt; fns.reduce((acc, fn: ICallbackFn) =&gt; {
  if (!isFunction(fn)) {
    fn = x =&gt; x;
  }
  return acc.then(fn).catch((err: any) =&gt; { throw err });
}, PromiseLike.resolve(x));
}
复制代码
</code></pre></div><ul><li><p>假设有多个函数，我们可以通过这样的操作来将它们组合，组合的内容是处理函数。</p> <div class="language- extra-class"><pre class="language-text"><code>function addThree(x) {
return x + 3;
}
function addFive(x) {
return x + 5;
}
const addEight = ProimseLike.sequence([addThree, addFive]);
addEight(2); // 10
复制代码
</code></pre></div></li> <li><p>上面的函数其实已经实现了串行；还可以做一些改动把每个值按顺序保存下来。</p></li></ul> <h4 id="promise-sequencebyorder"><a href="#promise-sequencebyorder" class="header-anchor">#</a> <code>Promise.sequenceByOrder</code></h4> <ul><li><p>该方法顺序执行函数，并返回按完成顺序排列的值。</p> <div class="language- extra-class"><pre class="language-text"><code>/**
</code></pre></div></li> <li><p>串行执行所有 promises,并返回按返回顺序排列的数组</p></li> <li><p>注意接收的参数是返回 promise 实例的函数组成的数组</p></li> <li><p>@param promises</p></li> <li><p>@returns */ static sequenceByOrder(promises: Array) { return new PromiseLike((resolve) =&gt; { let promiseResults: any = []; const reduceRes = promises.reduce((prevPromise, currentPromise: ICallbackFn, currentIndex: number) =&gt; { return prevPromise.then((val: any) =&gt; { promiseResults.push(val); const newVal = currentPromise(val); // 最后一次循环时保存，并剔除第一个值（默认 undefined) if (currentIndex === promises.length - 1) { promiseResults.unshift(); } return newVal; }); }, PromiseLike.resolve()); reduceRes.then((val: any) =&gt; { promiseResults.push(val); resolve(promiseResults); }); }); } 复制代码</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>#### `Promise.map`

- 定义一个可以处理所有 `promise` 值的函数，类似数组的 `map` 方法。

```ts
/**
* 对每个 promise 的值进行特定的处理
* Promise.map([p1, p2, p3], (val, resolve) =&gt; {
*   resolve(val + 1);
* })
* @param promises
* @param fn
* @returns
*/
static map(promises: Array&lt;IPromiseType&gt;, fn: any) {
return PromiseLike.all(promises.map((currentPromise) =&gt; {
  return new PromiseLike((resolve) =&gt; {
    if (!isFunction(fn)) {
      fn = (val:any, resolve: ICallbackFn) =&gt; resolve(val);
    }
    fn(currentPromise, resolve);
  })
}));
}
复制代码
</code></pre></div><h4 id="promise-observe"><a href="#promise-observe" class="header-anchor">#</a> <code>Promise.observe</code></h4> <ul><li><p>定义这样一个函数，用于清理 <code>promise</code> 相关的副作用，通常用在 <code>Promise.race</code> 中。假设我们使用 <code>Promise.race</code> 来设定超时，但仍然希望超时的场景里能够处理数据。</p> <div class="language- extra-class"><pre class="language-text"><code>/**
</code></pre></div></li> <li><p>Promise.race([Promise.observe(p, cleanup // 处理函数), timeoutFn // 超时函数])</p></li> <li><p>@param promise</p></li> <li><p>@param fn</p></li> <li><p>@returns */ static observe(promise: IPromiseType, fn: ICallbackFn) { promise .then((res: any) =&gt; { PromiseLike.resolve(res).then(fn); }, (err) =&gt; { PromiseLike.resolve(err).then(fn); }); return promise; } 复制代码</p></li></ul> <div class="language- extra-class"><pre class="language-text"><code>## 06.源码

### 06.01 部分源码

- 所有源码虽不多，全部张贴出来也比较占版面。下面是 `then` 的完整实现。

```ts
class PromiseLike {
/**
 * 根据当前不同状态来执行对应逻辑
* 如果在默认状态就是注册对应事件
* 如果状态变化则是执行对应事件
* @param onFulfilled
* @param onRejected
* @returns
*/
then = (onFulfilled?: CallbackParams, onRejected?: CallbackParams) =&gt; {
  // 默认处理！！！
  onFulfilled = isFunction(onFulfilled) ? onFulfilled : value =&gt; value;
  onRejected = isFunction(onRejected) ? onRejected : err =&gt; { throw err };

  /**
   * 该实现遵循 Promise/A+ 规范
  * https://github.com/promises-aplus/promises-spec
  * @param promise
  * @param x
  * @param resolve
  * @param reject
  * @returns
  */
  const resolvePromise = (promise: IPromiseType, x: any, resolve: ICallbackFn, reject: ICallbackFn) =&gt; {
    // 返回的 promise 不可以是当前的 promise 否则会造成死循环
    if (newPromise === x) {
      reject(new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;'));
    }
    // 对可能是 thenable 接口实现的对象判断
    if (isObject(x) || isFunction(x)) {
      if (x === null) {
        return resolve(x);
      }
      let thenCb;
      try {
        thenCb = x.then;
      } catch (error) {
        return reject(error);
      }

      // 如果是 thenable 的对象，则调用其 then 方法
      // 这一步涵盖了 Promise 实例的可能性
      if (isFunction(thenCb)) {
        let isCalled = false;
        try {
          thenCb.call(
            x, // 指向当前函数或对象
            (y: any) =&gt; {
              // 如果 resolvePromise 和 rejectPromise 都可能被调用
              // 则只需调用第一次（resolvePromise 或 rejectPromise），后续无需再执行
              if (isCalled) return;
              isCalled = true;
              // 传入当前函数，以实现递归展开调用
              resolvePromise(promise, y, resolve, reject);
            },
            (r: any) =&gt; {
              // 对应前面任意的调用之后，就不再只需后续逻辑
              if (isCalled) return;
              isCalled = true;
              reject(r);
            }
          )
        } catch (error) {
          if (isCalled) return;
          reject(error);
        }
      } else {
        resolve(x);
      }
    } else {
      resolve(x);
    }
  }

  // 定义变量，用于传参进行比较
  const newPromise = new PromiseLike((resolve, reject) =&gt; {
    /**
     * 封装完成回调函数
    * @param val
    */
    const handleFulfilled = (val: any) =&gt; {
      try {
        const x = onFulfilled &amp;&amp; onFulfilled(val);
        resolvePromise(newPromise, x, resolve, reject);
      } catch (error) {
        // 如果当前执行逻辑内发生异常，则抛出异常
        reject(error);
      };
    };

    /**
     * 封装错误回调函数
    * @param val
    */
    const handleRejected = (val: any) =&gt; {
      try {
        const x = onRejected &amp;&amp; onRejected(val);
        resolvePromise(newPromise, x, resolve, reject);
      } catch (error) {
        reject(error);
      }
    }

    switch (this.PromiseState) {
      case PROMISE_STATES.PENDING:
        this.resolveCallbackQueues.push(handleFulfilled);
        this.rejectCallbackQueues.push(handleRejected);
        break;
      case PROMISE_STATES.FULFILLED:
        handleFulfilled(this.PromiseResult);
        break;
      case PROMISE_STATES.REJECTED:
        handleRejected(this.PromiseResult);
        break;
    }
  });

  return newPromise;
}
}
复制代码
</code></pre></div><h3 id="_06-02-全部源码"><a href="#_06-02-全部源码" class="header-anchor">#</a> 06.02 全部源码</h3> <ul><li><strong>Github 地址</strong>[22]</li></ul> <h2 id="_07-小结"><a href="#_07-小结" class="header-anchor">#</a> 07.小结</h2> <ul><li><p>在这次尝试实现 <code>Promise</code> 的过程中，自己也在边写边学。这是我理解和实践的整个思路，并不一定适用其他人；希望它能作为一种参考，启发或者影响到他人。在写这篇文章之前，我没想到会投入了整整两天时间，却也只是弄懂了些皮毛。而 <code>Promise</code> 内部显然还有许多值得探讨的地方，涉及的微任务， <code>async/await</code> 相关，迭代器和生成器；只是目前精力所限，先止于此。后面也许会解析迭代器和生成器的内容。</p></li> <li><p>整个实践，也是自己练习 <code>typescipt</code> 的过程，这里我使用类的方式编写，主要是便于自己理解；但它也完全可以用函数实现。<code>typescript</code> 编译后的代码就是函数的实现，而且是 js. 可以直接查看下面的地址了解。另外，其中内容的编译转换也是值得探索的。</p></li> <li><ul><li><strong>Github</strong>**：https://github.com/kyriejoshua/promise-like/blob/master/dist/index.js**</li></ul></li></ul> <p>关于本文</p> <h1 id="作者-deadpool-ky"><a href="#作者-deadpool-ky" class="header-anchor">#</a> 作者：deadpool_ky</h1> <p>https://juejin.cn/post/6987674192166518821</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">11/8/2024, 10:19:43 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/mdn/2-promise/基于把原生ajax封装为Promise形式.html" class="prev">
        基于把原生ajax封装为Promise形式。
      </a></span> <span class="next"><a href="/mdn/2-promise/异步循环打印.html">
        实现异步循环打印
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.ae400df5.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/203.4ebeba02.js" defer></script>
  </body>
</html>
