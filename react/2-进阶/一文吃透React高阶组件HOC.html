<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>一文吃透React高阶组件HOC | 前端收集</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/logo.webp">
    <link rel="manifest" href="/manifest.json">
    <meta name="description" content="前端相关知识归纳总结">
    <meta name="keywords" content="blog,react,node,js">
    
    <link rel="preload" href="/assets/css/0.styles.b4a844ec.css" as="style"><link rel="preload" href="/assets/js/app.ae400df5.js" as="script"><link rel="preload" href="/assets/js/2.57da4f88.js" as="script"><link rel="preload" href="/assets/js/1.a76cc220.js" as="script"><link rel="preload" href="/assets/js/467.e6370736.js" as="script"><link rel="prefetch" href="/assets/js/10.50f73657.js"><link rel="prefetch" href="/assets/js/100.f9ccbc6f.js"><link rel="prefetch" href="/assets/js/101.c20baa36.js"><link rel="prefetch" href="/assets/js/102.4ce575e4.js"><link rel="prefetch" href="/assets/js/103.6ddf9f4a.js"><link rel="prefetch" href="/assets/js/104.e8bd0c3f.js"><link rel="prefetch" href="/assets/js/105.d0a85c47.js"><link rel="prefetch" href="/assets/js/106.4b3aadee.js"><link rel="prefetch" href="/assets/js/107.436e7f8f.js"><link rel="prefetch" href="/assets/js/108.f46692dc.js"><link rel="prefetch" href="/assets/js/109.322908a6.js"><link rel="prefetch" href="/assets/js/11.0390ceee.js"><link rel="prefetch" href="/assets/js/110.9181da82.js"><link rel="prefetch" href="/assets/js/111.c451b4da.js"><link rel="prefetch" href="/assets/js/112.196b195d.js"><link rel="prefetch" href="/assets/js/113.d65148d0.js"><link rel="prefetch" href="/assets/js/114.5566de19.js"><link rel="prefetch" href="/assets/js/115.12d1619e.js"><link rel="prefetch" href="/assets/js/116.d2f23fe7.js"><link rel="prefetch" href="/assets/js/117.d5fa2588.js"><link rel="prefetch" href="/assets/js/118.79455d12.js"><link rel="prefetch" href="/assets/js/119.b43c99e9.js"><link rel="prefetch" href="/assets/js/12.f88bec36.js"><link rel="prefetch" href="/assets/js/120.f321d53f.js"><link rel="prefetch" href="/assets/js/121.286fed99.js"><link rel="prefetch" href="/assets/js/122.ff0af27d.js"><link rel="prefetch" href="/assets/js/123.00138c02.js"><link rel="prefetch" href="/assets/js/124.25640250.js"><link rel="prefetch" href="/assets/js/125.cb2f28a6.js"><link rel="prefetch" href="/assets/js/126.e8ec0fe7.js"><link rel="prefetch" href="/assets/js/127.0fdd48c2.js"><link rel="prefetch" href="/assets/js/128.38b675a9.js"><link rel="prefetch" href="/assets/js/129.7819df5c.js"><link rel="prefetch" href="/assets/js/13.963ad03b.js"><link rel="prefetch" href="/assets/js/130.a58f0a09.js"><link rel="prefetch" href="/assets/js/131.4a0133b5.js"><link rel="prefetch" href="/assets/js/132.24e842c4.js"><link rel="prefetch" href="/assets/js/133.be3bb854.js"><link rel="prefetch" href="/assets/js/134.8c4662c6.js"><link rel="prefetch" href="/assets/js/135.03d2f395.js"><link rel="prefetch" href="/assets/js/136.acf07647.js"><link rel="prefetch" href="/assets/js/137.f0fa48ad.js"><link rel="prefetch" href="/assets/js/138.843d86f2.js"><link rel="prefetch" href="/assets/js/139.015086b5.js"><link rel="prefetch" href="/assets/js/14.512f15b9.js"><link rel="prefetch" href="/assets/js/140.5468056b.js"><link rel="prefetch" href="/assets/js/141.9bf65de6.js"><link rel="prefetch" href="/assets/js/142.63b38359.js"><link rel="prefetch" href="/assets/js/143.55120954.js"><link rel="prefetch" href="/assets/js/144.e3d71ef2.js"><link rel="prefetch" href="/assets/js/145.470a4869.js"><link rel="prefetch" href="/assets/js/146.574b3929.js"><link rel="prefetch" href="/assets/js/147.28c0b405.js"><link rel="prefetch" href="/assets/js/148.08f963f8.js"><link rel="prefetch" href="/assets/js/149.0b296978.js"><link rel="prefetch" href="/assets/js/15.a674496c.js"><link rel="prefetch" href="/assets/js/150.651bd19a.js"><link rel="prefetch" href="/assets/js/151.d2029876.js"><link rel="prefetch" href="/assets/js/152.32f253ce.js"><link rel="prefetch" href="/assets/js/153.ceb29b56.js"><link rel="prefetch" href="/assets/js/154.6a7f6d29.js"><link rel="prefetch" href="/assets/js/155.50aaf5d9.js"><link rel="prefetch" href="/assets/js/156.036e250b.js"><link rel="prefetch" href="/assets/js/157.c2435840.js"><link rel="prefetch" href="/assets/js/158.242ba411.js"><link rel="prefetch" href="/assets/js/159.136ff0a3.js"><link rel="prefetch" href="/assets/js/16.ed7e507f.js"><link rel="prefetch" href="/assets/js/160.25dcaecf.js"><link rel="prefetch" href="/assets/js/161.ab904d4e.js"><link rel="prefetch" href="/assets/js/162.04b69881.js"><link rel="prefetch" href="/assets/js/163.e7e749f8.js"><link rel="prefetch" href="/assets/js/164.71f53227.js"><link rel="prefetch" href="/assets/js/165.5841cd1a.js"><link rel="prefetch" href="/assets/js/166.28071d6e.js"><link rel="prefetch" href="/assets/js/167.93ce97d2.js"><link rel="prefetch" href="/assets/js/168.f3b2972c.js"><link rel="prefetch" href="/assets/js/169.aa7f77f0.js"><link rel="prefetch" href="/assets/js/17.de667ca5.js"><link rel="prefetch" href="/assets/js/170.cfdf36f3.js"><link rel="prefetch" href="/assets/js/171.e542ad9a.js"><link rel="prefetch" href="/assets/js/172.2101f9ed.js"><link rel="prefetch" href="/assets/js/173.8f875d74.js"><link rel="prefetch" href="/assets/js/174.61572c8b.js"><link rel="prefetch" href="/assets/js/175.2ce966d7.js"><link rel="prefetch" href="/assets/js/176.bf7661ff.js"><link rel="prefetch" href="/assets/js/177.99ab75ff.js"><link rel="prefetch" href="/assets/js/178.8c053eff.js"><link rel="prefetch" href="/assets/js/179.bb56672f.js"><link rel="prefetch" href="/assets/js/18.b44e84af.js"><link rel="prefetch" href="/assets/js/180.44be886d.js"><link rel="prefetch" href="/assets/js/181.a635f8b4.js"><link rel="prefetch" href="/assets/js/182.43ee494e.js"><link rel="prefetch" href="/assets/js/183.7f8013e7.js"><link rel="prefetch" href="/assets/js/184.995eba6d.js"><link rel="prefetch" href="/assets/js/185.ae8dc8fc.js"><link rel="prefetch" href="/assets/js/186.f5f3b8d8.js"><link rel="prefetch" href="/assets/js/187.0b834066.js"><link rel="prefetch" href="/assets/js/188.de0798b4.js"><link rel="prefetch" href="/assets/js/189.bd73bd48.js"><link rel="prefetch" href="/assets/js/19.5b5ad6a1.js"><link rel="prefetch" href="/assets/js/190.3b34618c.js"><link rel="prefetch" href="/assets/js/191.d69ac5ae.js"><link rel="prefetch" href="/assets/js/192.6fb41323.js"><link rel="prefetch" href="/assets/js/193.deec3471.js"><link rel="prefetch" href="/assets/js/194.a936f543.js"><link rel="prefetch" href="/assets/js/195.257a9d86.js"><link rel="prefetch" href="/assets/js/196.b04a1424.js"><link rel="prefetch" href="/assets/js/197.b1b12256.js"><link rel="prefetch" href="/assets/js/198.d3539378.js"><link rel="prefetch" href="/assets/js/199.802facc3.js"><link rel="prefetch" href="/assets/js/20.6800493a.js"><link rel="prefetch" href="/assets/js/200.c2e3da4f.js"><link rel="prefetch" href="/assets/js/201.9b119f49.js"><link rel="prefetch" href="/assets/js/202.283e51cb.js"><link rel="prefetch" href="/assets/js/203.4ebeba02.js"><link rel="prefetch" href="/assets/js/204.a3680104.js"><link rel="prefetch" href="/assets/js/205.e89e1221.js"><link rel="prefetch" href="/assets/js/206.a2159b40.js"><link rel="prefetch" href="/assets/js/207.30aa8a56.js"><link rel="prefetch" href="/assets/js/208.25e87523.js"><link rel="prefetch" href="/assets/js/209.1feb11d6.js"><link rel="prefetch" href="/assets/js/21.6589052c.js"><link rel="prefetch" href="/assets/js/210.3988d49f.js"><link rel="prefetch" href="/assets/js/211.c35b6127.js"><link rel="prefetch" href="/assets/js/212.a47a605d.js"><link rel="prefetch" href="/assets/js/213.e67c2145.js"><link rel="prefetch" href="/assets/js/214.f2adf5ee.js"><link rel="prefetch" href="/assets/js/215.8af7fa44.js"><link rel="prefetch" href="/assets/js/216.c4c02e18.js"><link rel="prefetch" href="/assets/js/217.8a2ed0a4.js"><link rel="prefetch" href="/assets/js/218.5224a21c.js"><link rel="prefetch" href="/assets/js/219.85a23ded.js"><link rel="prefetch" href="/assets/js/22.f648d829.js"><link rel="prefetch" href="/assets/js/220.1a4b37cb.js"><link rel="prefetch" href="/assets/js/221.fd8b42a5.js"><link rel="prefetch" href="/assets/js/222.ab3b9c2e.js"><link rel="prefetch" href="/assets/js/223.7e579d8f.js"><link rel="prefetch" href="/assets/js/224.a9ba827c.js"><link rel="prefetch" href="/assets/js/225.e1612fcc.js"><link rel="prefetch" href="/assets/js/226.9c1af133.js"><link rel="prefetch" href="/assets/js/227.0bc3b51e.js"><link rel="prefetch" href="/assets/js/228.a0eba8af.js"><link rel="prefetch" href="/assets/js/229.5d1c84bb.js"><link rel="prefetch" href="/assets/js/23.79aa69fa.js"><link rel="prefetch" href="/assets/js/230.f83fdc59.js"><link rel="prefetch" href="/assets/js/231.9f82cedb.js"><link rel="prefetch" href="/assets/js/232.f97914ee.js"><link rel="prefetch" href="/assets/js/233.50ac2baa.js"><link rel="prefetch" href="/assets/js/234.d313f866.js"><link rel="prefetch" href="/assets/js/235.f5eb3748.js"><link rel="prefetch" href="/assets/js/236.d452db47.js"><link rel="prefetch" href="/assets/js/237.5199378b.js"><link rel="prefetch" href="/assets/js/238.d1c3107c.js"><link rel="prefetch" href="/assets/js/239.4e2b6d59.js"><link rel="prefetch" href="/assets/js/24.03ffbcca.js"><link rel="prefetch" href="/assets/js/240.b46f5ecd.js"><link rel="prefetch" href="/assets/js/241.7e9311b0.js"><link rel="prefetch" href="/assets/js/242.ede280f9.js"><link rel="prefetch" href="/assets/js/243.71efdf6e.js"><link rel="prefetch" href="/assets/js/244.1b089d77.js"><link rel="prefetch" href="/assets/js/245.47562a1b.js"><link rel="prefetch" href="/assets/js/246.35ce7ccb.js"><link rel="prefetch" href="/assets/js/247.0eea6dda.js"><link rel="prefetch" href="/assets/js/248.d606d51a.js"><link rel="prefetch" href="/assets/js/249.22a9c555.js"><link rel="prefetch" href="/assets/js/25.872464d2.js"><link rel="prefetch" href="/assets/js/250.7cf64a15.js"><link rel="prefetch" href="/assets/js/251.b6f787d7.js"><link rel="prefetch" href="/assets/js/252.8b9bedcd.js"><link rel="prefetch" href="/assets/js/253.5c63ec35.js"><link rel="prefetch" href="/assets/js/254.31ff9dc4.js"><link rel="prefetch" href="/assets/js/255.190e5f80.js"><link rel="prefetch" href="/assets/js/256.e68f87e0.js"><link rel="prefetch" href="/assets/js/257.3095f7a1.js"><link rel="prefetch" href="/assets/js/258.af517699.js"><link rel="prefetch" href="/assets/js/259.f10ece0f.js"><link rel="prefetch" href="/assets/js/26.bd6d2ac2.js"><link rel="prefetch" href="/assets/js/260.e8bbba00.js"><link rel="prefetch" href="/assets/js/261.5d9b1d5e.js"><link rel="prefetch" href="/assets/js/262.950474a9.js"><link rel="prefetch" href="/assets/js/263.3e7dca65.js"><link rel="prefetch" href="/assets/js/264.1017ad1a.js"><link rel="prefetch" href="/assets/js/265.99c4d846.js"><link rel="prefetch" href="/assets/js/266.8d1ea647.js"><link rel="prefetch" href="/assets/js/267.20e69579.js"><link rel="prefetch" href="/assets/js/268.4da84374.js"><link rel="prefetch" href="/assets/js/269.e3ad7859.js"><link rel="prefetch" href="/assets/js/27.814c713d.js"><link rel="prefetch" href="/assets/js/270.c5c4b40b.js"><link rel="prefetch" href="/assets/js/271.9c7294fd.js"><link rel="prefetch" href="/assets/js/272.3d41fdce.js"><link rel="prefetch" href="/assets/js/273.3eaafe8e.js"><link rel="prefetch" href="/assets/js/274.f98d5554.js"><link rel="prefetch" href="/assets/js/275.5ec6a4b8.js"><link rel="prefetch" href="/assets/js/276.0936dd89.js"><link rel="prefetch" href="/assets/js/277.33bd4dff.js"><link rel="prefetch" href="/assets/js/278.c383b31c.js"><link rel="prefetch" href="/assets/js/279.6df8b215.js"><link rel="prefetch" href="/assets/js/28.5229eb08.js"><link rel="prefetch" href="/assets/js/280.07169fc6.js"><link rel="prefetch" href="/assets/js/281.4b28be3f.js"><link rel="prefetch" href="/assets/js/282.79bba86e.js"><link rel="prefetch" href="/assets/js/283.32f592bc.js"><link rel="prefetch" href="/assets/js/284.fd9b6b59.js"><link rel="prefetch" href="/assets/js/285.df1454be.js"><link rel="prefetch" href="/assets/js/286.18b1703e.js"><link rel="prefetch" href="/assets/js/287.94781ca0.js"><link rel="prefetch" href="/assets/js/288.f21493cb.js"><link rel="prefetch" href="/assets/js/289.8fc283e3.js"><link rel="prefetch" href="/assets/js/29.a63c1057.js"><link rel="prefetch" href="/assets/js/290.3346a986.js"><link rel="prefetch" href="/assets/js/291.5fafa49e.js"><link rel="prefetch" href="/assets/js/292.ac874de4.js"><link rel="prefetch" href="/assets/js/293.19730c32.js"><link rel="prefetch" href="/assets/js/294.98ddc6d7.js"><link rel="prefetch" href="/assets/js/295.eae00758.js"><link rel="prefetch" href="/assets/js/296.1d81c552.js"><link rel="prefetch" href="/assets/js/297.5f86f97e.js"><link rel="prefetch" href="/assets/js/298.1bc558ca.js"><link rel="prefetch" href="/assets/js/299.d068c6b6.js"><link rel="prefetch" href="/assets/js/3.13e892f5.js"><link rel="prefetch" href="/assets/js/30.1b884b1b.js"><link rel="prefetch" href="/assets/js/300.c956e204.js"><link rel="prefetch" href="/assets/js/301.77127d95.js"><link rel="prefetch" href="/assets/js/302.1d7c4af3.js"><link rel="prefetch" href="/assets/js/303.2bcbc099.js"><link rel="prefetch" href="/assets/js/304.b2180761.js"><link rel="prefetch" href="/assets/js/305.3ac4a62e.js"><link rel="prefetch" href="/assets/js/306.1ce3e68d.js"><link rel="prefetch" href="/assets/js/307.6c3d9548.js"><link rel="prefetch" href="/assets/js/308.b777fbfa.js"><link rel="prefetch" href="/assets/js/309.e5d32660.js"><link rel="prefetch" href="/assets/js/31.68c1b4eb.js"><link rel="prefetch" href="/assets/js/310.fcda8acc.js"><link rel="prefetch" href="/assets/js/311.cde4dc35.js"><link rel="prefetch" href="/assets/js/312.98a0ee89.js"><link rel="prefetch" href="/assets/js/313.ce02630f.js"><link rel="prefetch" href="/assets/js/314.3883ac39.js"><link rel="prefetch" href="/assets/js/315.b6c9cd37.js"><link rel="prefetch" href="/assets/js/316.6cd33ea7.js"><link rel="prefetch" href="/assets/js/317.eb818350.js"><link rel="prefetch" href="/assets/js/318.e9e7da16.js"><link rel="prefetch" href="/assets/js/319.1edfec0a.js"><link rel="prefetch" href="/assets/js/32.64224241.js"><link rel="prefetch" href="/assets/js/320.f4728475.js"><link rel="prefetch" href="/assets/js/321.799c6e59.js"><link rel="prefetch" href="/assets/js/322.a701407b.js"><link rel="prefetch" href="/assets/js/323.803b7bcc.js"><link rel="prefetch" href="/assets/js/324.a73b88d8.js"><link rel="prefetch" href="/assets/js/325.f08e06ca.js"><link rel="prefetch" href="/assets/js/326.80813d35.js"><link rel="prefetch" href="/assets/js/327.8310d6c8.js"><link rel="prefetch" href="/assets/js/328.68f1b07a.js"><link rel="prefetch" href="/assets/js/329.04be32fe.js"><link rel="prefetch" href="/assets/js/33.b4859866.js"><link rel="prefetch" href="/assets/js/330.fbd486d3.js"><link rel="prefetch" href="/assets/js/331.bc43b814.js"><link rel="prefetch" href="/assets/js/332.838514e5.js"><link rel="prefetch" href="/assets/js/333.c647f10b.js"><link rel="prefetch" href="/assets/js/334.293d7db1.js"><link rel="prefetch" href="/assets/js/335.f60f98c5.js"><link rel="prefetch" href="/assets/js/336.d59a627e.js"><link rel="prefetch" href="/assets/js/337.719cd005.js"><link rel="prefetch" href="/assets/js/338.eb93d4b7.js"><link rel="prefetch" href="/assets/js/339.a38c5695.js"><link rel="prefetch" href="/assets/js/34.69c1bc55.js"><link rel="prefetch" href="/assets/js/340.9a4ce427.js"><link rel="prefetch" href="/assets/js/341.d39b4f2f.js"><link rel="prefetch" href="/assets/js/342.11fbba88.js"><link rel="prefetch" href="/assets/js/343.36030f9c.js"><link rel="prefetch" href="/assets/js/344.94fc0ac0.js"><link rel="prefetch" href="/assets/js/345.c6ef0cd3.js"><link rel="prefetch" href="/assets/js/346.3f3484bf.js"><link rel="prefetch" href="/assets/js/347.f6957922.js"><link rel="prefetch" href="/assets/js/348.df8650b3.js"><link rel="prefetch" href="/assets/js/349.402ca2e1.js"><link rel="prefetch" href="/assets/js/35.d8b00796.js"><link rel="prefetch" href="/assets/js/350.8a48f4c3.js"><link rel="prefetch" href="/assets/js/351.b5356e83.js"><link rel="prefetch" href="/assets/js/352.944301fd.js"><link rel="prefetch" href="/assets/js/353.8b170c06.js"><link rel="prefetch" href="/assets/js/354.97b92290.js"><link rel="prefetch" href="/assets/js/355.948e7095.js"><link rel="prefetch" href="/assets/js/356.5aaf9fe5.js"><link rel="prefetch" href="/assets/js/357.67c88167.js"><link rel="prefetch" href="/assets/js/358.e241fbe2.js"><link rel="prefetch" href="/assets/js/359.15b3166a.js"><link rel="prefetch" href="/assets/js/36.090e85b2.js"><link rel="prefetch" href="/assets/js/360.187f4fe6.js"><link rel="prefetch" href="/assets/js/361.a77fa57f.js"><link rel="prefetch" href="/assets/js/362.30ed8657.js"><link rel="prefetch" href="/assets/js/363.c8caaf0f.js"><link rel="prefetch" href="/assets/js/364.78f41e2e.js"><link rel="prefetch" href="/assets/js/365.55b8d5b3.js"><link rel="prefetch" href="/assets/js/366.d1c007ca.js"><link rel="prefetch" href="/assets/js/367.bc6a31fb.js"><link rel="prefetch" href="/assets/js/368.147012d3.js"><link rel="prefetch" href="/assets/js/369.94f25d03.js"><link rel="prefetch" href="/assets/js/37.bf92df67.js"><link rel="prefetch" href="/assets/js/370.37c8786f.js"><link rel="prefetch" href="/assets/js/371.037e513b.js"><link rel="prefetch" href="/assets/js/372.353d4826.js"><link rel="prefetch" href="/assets/js/373.3260442b.js"><link rel="prefetch" href="/assets/js/374.eabaedd4.js"><link rel="prefetch" href="/assets/js/375.f80e9c75.js"><link rel="prefetch" href="/assets/js/376.b041cafe.js"><link rel="prefetch" href="/assets/js/377.d6410416.js"><link rel="prefetch" href="/assets/js/378.0d21f78f.js"><link rel="prefetch" href="/assets/js/379.83c05c56.js"><link rel="prefetch" href="/assets/js/38.74932844.js"><link rel="prefetch" href="/assets/js/380.c41e1704.js"><link rel="prefetch" href="/assets/js/381.52c6dcbf.js"><link rel="prefetch" href="/assets/js/382.d2998ea4.js"><link rel="prefetch" href="/assets/js/383.160918fa.js"><link rel="prefetch" href="/assets/js/384.6e3e4604.js"><link rel="prefetch" href="/assets/js/385.e514c0b7.js"><link rel="prefetch" href="/assets/js/386.3cab7b43.js"><link rel="prefetch" href="/assets/js/387.7b7aa4c3.js"><link rel="prefetch" href="/assets/js/388.1675a9c8.js"><link rel="prefetch" href="/assets/js/389.f5e5e9e4.js"><link rel="prefetch" href="/assets/js/39.45a654d9.js"><link rel="prefetch" href="/assets/js/390.5bbca72c.js"><link rel="prefetch" href="/assets/js/391.4e95a939.js"><link rel="prefetch" href="/assets/js/392.8eb7d12f.js"><link rel="prefetch" href="/assets/js/393.f72f9473.js"><link rel="prefetch" href="/assets/js/394.1cea58b3.js"><link rel="prefetch" href="/assets/js/395.33fa0847.js"><link rel="prefetch" href="/assets/js/396.8ef17642.js"><link rel="prefetch" href="/assets/js/397.dd02eee1.js"><link rel="prefetch" href="/assets/js/398.23ea33a3.js"><link rel="prefetch" href="/assets/js/399.84a4e8db.js"><link rel="prefetch" href="/assets/js/4.5bdb9365.js"><link rel="prefetch" href="/assets/js/40.7cc37d90.js"><link rel="prefetch" href="/assets/js/400.0597181f.js"><link rel="prefetch" href="/assets/js/401.9cb4c0e2.js"><link rel="prefetch" href="/assets/js/402.41ddf5c4.js"><link rel="prefetch" href="/assets/js/403.afa305eb.js"><link rel="prefetch" href="/assets/js/404.3831ec8d.js"><link rel="prefetch" href="/assets/js/405.b79a51fb.js"><link rel="prefetch" href="/assets/js/406.dd6191a5.js"><link rel="prefetch" href="/assets/js/407.d2e12f04.js"><link rel="prefetch" href="/assets/js/408.56c2fc48.js"><link rel="prefetch" href="/assets/js/409.25a15725.js"><link rel="prefetch" href="/assets/js/41.78331f9e.js"><link rel="prefetch" href="/assets/js/410.dd6c1352.js"><link rel="prefetch" href="/assets/js/411.6d95d902.js"><link rel="prefetch" href="/assets/js/412.da6546bd.js"><link rel="prefetch" href="/assets/js/413.39d34e64.js"><link rel="prefetch" href="/assets/js/414.aaa215f3.js"><link rel="prefetch" href="/assets/js/415.b41c61b6.js"><link rel="prefetch" href="/assets/js/416.139592a7.js"><link rel="prefetch" href="/assets/js/417.324a89a1.js"><link rel="prefetch" href="/assets/js/418.676f7dcb.js"><link rel="prefetch" href="/assets/js/419.9350419c.js"><link rel="prefetch" href="/assets/js/42.a22391d6.js"><link rel="prefetch" href="/assets/js/420.0462f81e.js"><link rel="prefetch" href="/assets/js/421.a6efdd34.js"><link rel="prefetch" href="/assets/js/422.569428e8.js"><link rel="prefetch" href="/assets/js/423.8cb41fe5.js"><link rel="prefetch" href="/assets/js/424.98a9d128.js"><link rel="prefetch" href="/assets/js/425.62b51cfb.js"><link rel="prefetch" href="/assets/js/426.7b3a49e4.js"><link rel="prefetch" href="/assets/js/427.f99d9c10.js"><link rel="prefetch" href="/assets/js/428.73db8fe6.js"><link rel="prefetch" href="/assets/js/429.05f1741b.js"><link rel="prefetch" href="/assets/js/43.8946d7e2.js"><link rel="prefetch" href="/assets/js/430.8b43f070.js"><link rel="prefetch" href="/assets/js/431.d85a79d6.js"><link rel="prefetch" href="/assets/js/432.7373e34b.js"><link rel="prefetch" href="/assets/js/433.4be17add.js"><link rel="prefetch" href="/assets/js/434.81670bcf.js"><link rel="prefetch" href="/assets/js/435.6aa95ea5.js"><link rel="prefetch" href="/assets/js/436.4223c356.js"><link rel="prefetch" href="/assets/js/437.13f276dc.js"><link rel="prefetch" href="/assets/js/438.7c6e503d.js"><link rel="prefetch" href="/assets/js/439.6f9afc22.js"><link rel="prefetch" href="/assets/js/44.2a678f4a.js"><link rel="prefetch" href="/assets/js/440.5c949914.js"><link rel="prefetch" href="/assets/js/441.7dc7c8e4.js"><link rel="prefetch" href="/assets/js/442.bfec8250.js"><link rel="prefetch" href="/assets/js/443.0b932152.js"><link rel="prefetch" href="/assets/js/444.ecc56127.js"><link rel="prefetch" href="/assets/js/445.3a1eefa1.js"><link rel="prefetch" href="/assets/js/446.07410371.js"><link rel="prefetch" href="/assets/js/447.920996c3.js"><link rel="prefetch" href="/assets/js/448.9b5b5588.js"><link rel="prefetch" href="/assets/js/449.40afb76e.js"><link rel="prefetch" href="/assets/js/45.a716cdab.js"><link rel="prefetch" href="/assets/js/450.15845e93.js"><link rel="prefetch" href="/assets/js/451.c0454122.js"><link rel="prefetch" href="/assets/js/452.076ca38b.js"><link rel="prefetch" href="/assets/js/453.35add2cd.js"><link rel="prefetch" href="/assets/js/454.fed25dd2.js"><link rel="prefetch" href="/assets/js/455.a3232b7e.js"><link rel="prefetch" href="/assets/js/456.803d9cea.js"><link rel="prefetch" href="/assets/js/457.0a884768.js"><link rel="prefetch" href="/assets/js/458.69b6cc02.js"><link rel="prefetch" href="/assets/js/459.d8e1df18.js"><link rel="prefetch" href="/assets/js/46.53b78a16.js"><link rel="prefetch" href="/assets/js/460.a4980d6e.js"><link rel="prefetch" href="/assets/js/461.68d3e1c1.js"><link rel="prefetch" href="/assets/js/462.7930ea12.js"><link rel="prefetch" href="/assets/js/463.48a62ed8.js"><link rel="prefetch" href="/assets/js/464.5c42fe51.js"><link rel="prefetch" href="/assets/js/465.b65a0e95.js"><link rel="prefetch" href="/assets/js/466.63474609.js"><link rel="prefetch" href="/assets/js/468.a6cd9285.js"><link rel="prefetch" href="/assets/js/469.3df61389.js"><link rel="prefetch" href="/assets/js/47.dc9468b3.js"><link rel="prefetch" href="/assets/js/470.b956e72b.js"><link rel="prefetch" href="/assets/js/471.227fb33d.js"><link rel="prefetch" href="/assets/js/472.407485a3.js"><link rel="prefetch" href="/assets/js/473.9ab2c50d.js"><link rel="prefetch" href="/assets/js/474.dd36f932.js"><link rel="prefetch" href="/assets/js/475.7634085c.js"><link rel="prefetch" href="/assets/js/476.6869c979.js"><link rel="prefetch" href="/assets/js/477.b8bbd1aa.js"><link rel="prefetch" href="/assets/js/478.d85549c5.js"><link rel="prefetch" href="/assets/js/479.a549954b.js"><link rel="prefetch" href="/assets/js/48.f62c6508.js"><link rel="prefetch" href="/assets/js/480.964f2b40.js"><link rel="prefetch" href="/assets/js/481.68f5f905.js"><link rel="prefetch" href="/assets/js/482.32b674c2.js"><link rel="prefetch" href="/assets/js/483.6574c15d.js"><link rel="prefetch" href="/assets/js/484.63db4bff.js"><link rel="prefetch" href="/assets/js/485.0ecd7c6e.js"><link rel="prefetch" href="/assets/js/486.44a1de5d.js"><link rel="prefetch" href="/assets/js/487.fad12e99.js"><link rel="prefetch" href="/assets/js/488.169f32db.js"><link rel="prefetch" href="/assets/js/489.7ea816a6.js"><link rel="prefetch" href="/assets/js/49.f155d78a.js"><link rel="prefetch" href="/assets/js/490.d35de876.js"><link rel="prefetch" href="/assets/js/491.08874d90.js"><link rel="prefetch" href="/assets/js/492.088a7e6e.js"><link rel="prefetch" href="/assets/js/493.61d62bf4.js"><link rel="prefetch" href="/assets/js/494.b0515138.js"><link rel="prefetch" href="/assets/js/495.60587f26.js"><link rel="prefetch" href="/assets/js/496.d66df398.js"><link rel="prefetch" href="/assets/js/497.7c88f879.js"><link rel="prefetch" href="/assets/js/498.73e1e0cf.js"><link rel="prefetch" href="/assets/js/499.8162e0b6.js"><link rel="prefetch" href="/assets/js/5.7c68fdb5.js"><link rel="prefetch" href="/assets/js/50.d2b62498.js"><link rel="prefetch" href="/assets/js/500.8b0de440.js"><link rel="prefetch" href="/assets/js/501.0894844d.js"><link rel="prefetch" href="/assets/js/502.1c0d1c3c.js"><link rel="prefetch" href="/assets/js/503.3e3f2a4a.js"><link rel="prefetch" href="/assets/js/504.cca812a4.js"><link rel="prefetch" href="/assets/js/505.8a1f3adc.js"><link rel="prefetch" href="/assets/js/506.35d49763.js"><link rel="prefetch" href="/assets/js/507.4fd3c268.js"><link rel="prefetch" href="/assets/js/508.aa2ba78c.js"><link rel="prefetch" href="/assets/js/509.cc7d97eb.js"><link rel="prefetch" href="/assets/js/51.7b12b0f0.js"><link rel="prefetch" href="/assets/js/510.73e3254c.js"><link rel="prefetch" href="/assets/js/511.bd21926b.js"><link rel="prefetch" href="/assets/js/512.8b796161.js"><link rel="prefetch" href="/assets/js/513.da11e0bf.js"><link rel="prefetch" href="/assets/js/514.5a620685.js"><link rel="prefetch" href="/assets/js/515.9a4b1681.js"><link rel="prefetch" href="/assets/js/516.de55e3ca.js"><link rel="prefetch" href="/assets/js/517.2b3b1dd5.js"><link rel="prefetch" href="/assets/js/518.aa28e969.js"><link rel="prefetch" href="/assets/js/519.91a752a1.js"><link rel="prefetch" href="/assets/js/52.3391993d.js"><link rel="prefetch" href="/assets/js/520.49c84d3e.js"><link rel="prefetch" href="/assets/js/521.545008de.js"><link rel="prefetch" href="/assets/js/522.11773c74.js"><link rel="prefetch" href="/assets/js/523.5b523166.js"><link rel="prefetch" href="/assets/js/524.9d7c8f5c.js"><link rel="prefetch" href="/assets/js/53.a67a7068.js"><link rel="prefetch" href="/assets/js/54.af0dccf3.js"><link rel="prefetch" href="/assets/js/55.cdae5880.js"><link rel="prefetch" href="/assets/js/56.4d918bef.js"><link rel="prefetch" href="/assets/js/57.5e9dea12.js"><link rel="prefetch" href="/assets/js/58.6cec08ff.js"><link rel="prefetch" href="/assets/js/59.65771179.js"><link rel="prefetch" href="/assets/js/6.c8da7ca7.js"><link rel="prefetch" href="/assets/js/60.8f859a65.js"><link rel="prefetch" href="/assets/js/61.43bff54c.js"><link rel="prefetch" href="/assets/js/62.b8e9e509.js"><link rel="prefetch" href="/assets/js/63.5149a7b9.js"><link rel="prefetch" href="/assets/js/64.961c386a.js"><link rel="prefetch" href="/assets/js/65.73f66baf.js"><link rel="prefetch" href="/assets/js/66.b5930577.js"><link rel="prefetch" href="/assets/js/67.40a0db0c.js"><link rel="prefetch" href="/assets/js/68.6212d2a9.js"><link rel="prefetch" href="/assets/js/69.0cd6b5c4.js"><link rel="prefetch" href="/assets/js/7.e4c88d0e.js"><link rel="prefetch" href="/assets/js/70.8e1f3dad.js"><link rel="prefetch" href="/assets/js/71.041fa5d5.js"><link rel="prefetch" href="/assets/js/72.7b626c12.js"><link rel="prefetch" href="/assets/js/73.78b38a87.js"><link rel="prefetch" href="/assets/js/74.6ec158a9.js"><link rel="prefetch" href="/assets/js/75.de5261fd.js"><link rel="prefetch" href="/assets/js/76.49878016.js"><link rel="prefetch" href="/assets/js/77.77eb5ec0.js"><link rel="prefetch" href="/assets/js/78.13279776.js"><link rel="prefetch" href="/assets/js/79.55cd4da6.js"><link rel="prefetch" href="/assets/js/80.2d4e5531.js"><link rel="prefetch" href="/assets/js/81.f00c64f4.js"><link rel="prefetch" href="/assets/js/82.af834374.js"><link rel="prefetch" href="/assets/js/83.42d97060.js"><link rel="prefetch" href="/assets/js/84.e6bc84a7.js"><link rel="prefetch" href="/assets/js/85.beeccec9.js"><link rel="prefetch" href="/assets/js/86.af675949.js"><link rel="prefetch" href="/assets/js/87.42f1b392.js"><link rel="prefetch" href="/assets/js/88.b5b8b77f.js"><link rel="prefetch" href="/assets/js/89.5892cf98.js"><link rel="prefetch" href="/assets/js/90.975b2533.js"><link rel="prefetch" href="/assets/js/91.64ccb26a.js"><link rel="prefetch" href="/assets/js/92.159aca5a.js"><link rel="prefetch" href="/assets/js/93.ca72cfb7.js"><link rel="prefetch" href="/assets/js/94.134a585d.js"><link rel="prefetch" href="/assets/js/95.83f34609.js"><link rel="prefetch" href="/assets/js/96.25383af1.js"><link rel="prefetch" href="/assets/js/97.404579a5.js"><link rel="prefetch" href="/assets/js/98.b15c1a8c.js"><link rel="prefetch" href="/assets/js/99.2757d9cd.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.5143d2e0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b4a844ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端收集</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/react/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/react-source/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/mdn/" class="nav-link">
  MDN
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  JS进阶
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/deploy/" class="nav-link">
  工程化
</a></div><div class="nav-item"><a href="/qa/" class="nav-link">
  QA
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="链接" class="dropdown-title"><span class="title">链接</span> <span class="arrow down"></span></button> <button type="button" aria-label="链接" class="mobile-dropdown-title"><span class="title">链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://note.aduang.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  note
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/chnduang/cv-collect-blog.git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/react/" class="nav-link router-link-active">
  React
</a></div><div class="nav-item"><a href="/react-source/" class="nav-link">
  源码解析
</a></div><div class="nav-item"><a href="/mdn/" class="nav-link">
  MDN
</a></div><div class="nav-item"><a href="/node/" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/advanced/" class="nav-link">
  JS进阶
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法
</a></div><div class="nav-item"><a href="/deploy/" class="nav-link">
  工程化
</a></div><div class="nav-item"><a href="/qa/" class="nav-link">
  QA
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="链接" class="dropdown-title"><span class="title">链接</span> <span class="arrow down"></span></button> <button type="button" aria-label="链接" class="mobile-dropdown-title"><span class="title">链接</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://note.aduang.cn/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  note
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://github.com/chnduang/cv-collect-blog.git" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/react/" aria-current="page" class="sidebar-link">目录</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/react/1-基础部分" class="sidebar-heading clickable"><span>基础部分</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/react/2-进阶" class="sidebar-heading clickable open"><span>进阶</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/2-%E8%BF%9B%E9%98%B6/" aria-current="page" class="sidebar-link">目录</a></li><li><a href="/react/2-进阶/React中的key有什么作用.html" class="sidebar-link">React中的key有什么作用？</a></li><li><a href="/react/2-进阶/Render如何强制它.html" class="sidebar-link">什么是 React 中的 Render 以及如何强制它？</a></li><li><a href="/react/2-进阶/react-setState执行机制.html" class="sidebar-link">React中的setState执行机制</a></li><li><a href="/react/2-进阶/react-svelte入门.html" class="sidebar-link">写给 React 开发者看的 Svelte入门</a></li><li><a href="/react/2-进阶/react16常见api以及原理剖析.html" class="sidebar-link">react16常见api以及原理剖析</a></li><li><a href="/react/2-进阶/react中key值得使用.html" class="sidebar-link">react 中 key 值得使用http://www.conardli.top/blog/article/React深入系列/React中key的正确使用方式.html#_1-为什么要使用key</a></li><li><a href="/react/2-进阶/setState执行机制.html" class="sidebar-link">setState 执行机制</a></li><li><a href="/react/2-进阶/一文吃透React高阶组件HOC.html" class="active sidebar-link">一文吃透React高阶组件HOC</a></li><li><a href="/react/2-进阶/五分钟带你掌握优先队列.html" class="sidebar-link">五分钟带你掌握优先队列</a></li><li><a href="/react/2-进阶/从mixin到hoc再到hook-1.html" class="sidebar-link">从mixin到hoc再到hook-1</a></li><li><a href="/react/2-进阶/从mixin到hoc再到hook-2.html" class="sidebar-link">从 mixin 到 hoc 再到 hook-2</a></li><li><a href="/react/2-进阶/从mixin到hoc再到hook-3.html" class="sidebar-link">从 mixin 到 hoc 再到 hook-3</a></li><li><a href="/react/2-进阶/从mixin到hoc再到hook-4.html" class="sidebar-link">从 mixin 到 hoc 再到 hook-4</a></li><li><a href="/react/2-进阶/前端架构之React领域驱动设计.html" class="sidebar-link">前端架构之 React 领域驱动设计</a></li><li><a href="/react/2-进阶/学好这些React设计模式1.html" class="sidebar-link">学好这些React设计模式-能让你的 React 项目飞起来</a></li><li><a href="/react/2-进阶/学好这些React设计模式2.html" class="sidebar-link">学好这些React设计模式-能让你的 React 项目飞起来</a></li><li><a href="/react/2-进阶/浅谈React中的XSS攻击.html" class="sidebar-link">浅谈 React 中的 XSS 攻击</a></li><li><a href="/react/2-进阶/说说对高阶组件的理解.html" class="sidebar-link">说说对高阶组件的理解？应用场景?</a></li><li><a href="/react/2-进阶/错误边界.html" class="sidebar-link">错误边界（Error Boundaries）</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/react/3-hooks" class="sidebar-heading clickable"><span>hooks</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/react/4-事件机制" class="sidebar-heading clickable"><span>事件机制</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/react/5-fiber" class="sidebar-heading clickable"><span>fiber</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/react/7-性能优化" class="sidebar-heading clickable"><span>性能优化</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/react/8-SSR" class="sidebar-heading clickable"><span>SSR</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/react/8-单元测试" class="sidebar-heading clickable"><span>单元测试</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="一文吃透react高阶组件hoc"><a href="#一文吃透react高阶组件hoc" class="header-anchor">#</a> 一文吃透React高阶组件HOC</h1> <blockquote><p><a href="https://mp.weixin.qq.com/s/W5pk2fuCHuRqPizwlnUnIQ" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/W5pk2fuCHuRqPizwlnUnIQ<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h1 id="一-前言"><a href="#一-前言" class="header-anchor">#</a> 一 前言</h1> <p><code>React</code>高阶组件(<code>HOC</code>)，对于很多<code>react</code>开发者来说并不陌生，它是灵活使用<code>react</code>组件的一种技巧，高阶组件本身不是组件，它是一个参数为组件，返回值也是一个组件的函数。高阶作用用于<strong>强化组件，复用逻辑，提升渲染性能等</strong>作用。高阶组件也并不是很难理解，其实接触过后还是蛮简单的，接下来我将按照，<strong>高阶组件理解？</strong>，<strong>高阶组件具体怎么使用？应用场景</strong>， <strong>高阶组件实践(源码级别)</strong> 为突破口，带大家详细了解一下高阶组件。本文篇幅比较长，建议收藏观看</p> <p>我们带着问题去开始今天的讨论：</p> <ul><li>1 什么是高阶组件，它解决了什么问题？</li> <li>2 有几种高阶组件，它们优缺点是什么？</li> <li>3 如何写一个优秀高阶组件？</li> <li>4 <code>hoc</code>怎么处理静态属性，跨层级<code>ref</code>等问题？</li> <li>5 高阶组件怎么控制渲染，隔离渲染？</li> <li>6 高阶组件怎么监控原始组件的状态？</li> <li>...</li></ul> <blockquote><p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p></blockquote> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXvHqmbKib3PNgQiaxiaJ5dZYicz6nNNIzJR8beFsTUbDcvrh8hxSYMFGQXw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h1 id="二-全方位看高阶组件"><a href="#二-全方位看高阶组件" class="header-anchor">#</a> 二 全方位看高阶组件</h1> <h2 id="_1-几种包装强化组件的方式"><a href="#_1-几种包装强化组件的方式" class="header-anchor">#</a> 1 几种包装强化组件的方式</h2> <h3 id="_1-mixin模式"><a href="#_1-mixin模式" class="header-anchor">#</a> ① mixin模式</h3> <p><strong>原型图</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXFKuSNPhezUhs2TNsfnfIjmeqFfqQdM6zcOxANCuNEcBwAaR928UtsQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <h4 id="老版本的react-mixins"><a href="#老版本的react-mixins" class="header-anchor">#</a> 老版本的<code>react-mixins</code></h4> <p>在<code>react</code>初期提供一种组合方法。通过<code>React.createClass</code>,加入<code>mixins</code>属性，具体用法和<code>vue</code> 中<code>mixins</code>相似。具体实现如下。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const customMixin = {  componentDidMount(){    console.log( '------componentDidMount------' )  },  say(){    console.log(this.state.name)  }}
const APP = React.createClass({  mixins: [ customMixin ],  getInitialState(){    return {      name:'alien'    }  },  render(){    const { name  } = this.state    return &lt;div&gt; hello ,world , my name is { name } &lt;/div&gt;  }})
</code></pre></div><p>这种<code>mixins</code>只能存在<code>createClass</code>中，后来<code>React.createClass</code>连同<code>mixins</code>这种模式被废弃了。<code>mixins</code>会带来一些负面的影响。</p> <ul><li>1 mixin引入了隐式依赖关系。</li> <li>2 不同mixins之间可能会有先后顺序甚至代码冲突覆盖的问题</li> <li>3 mixin代码会导致滚雪球式的复杂性</li></ul> <h4 id="衍生方式"><a href="#衍生方式" class="header-anchor">#</a> 衍生方式</h4> <p><code>createClass</code>的废弃，不代表<code>mixin</code>模式退出<code>react</code>舞台，在有状态组件<code>class</code>，我们可以通过<strong>原型链继承</strong>来实现<code>mixins</code>。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const customMixin = {  /* 自定义 mixins */  componentDidMount(){    console.log( '------componentDidMount------' )  },  say(){    console.log(this.state.name)  }}
function componentClassMixins(Component,mixin){ /* 继承 */  for(let key in mixin){    Component.prototype[key] = mixin[key]  }}
class Index extends React.Component{  constructor(){    super()    this.state={  name:'alien' }  }  render(){    return &lt;div&gt; hello,world      &lt;button onClick={ this.say.bind(this) } &gt; to say &lt;/button&gt;    &lt;/div&gt;  }}componentClassMixins(Index,customMixin)
</code></pre></div><h3 id="_2extends继承模式"><a href="#_2extends继承模式" class="header-anchor">#</a> ②extends继承模式</h3> <p><strong>原型图</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXy6wIa4Xf7Sdop92zIlibRNia5ufhqNanetpjPSb4Kx5uvaBThWNicwpjw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p>在<code>class</code>组件盛行之后，我们可以通过继承的方式进一步的强化我们的组件。这种模式的好处在于，可以封装基础功能组件，然后根据需要去<code>extends</code>我们的基础组件，按需强化组件，但是值得注意的是，必须要对基础组件有足够的掌握，否则会造成一些列意想不到的情况发生。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Base extends React.Component{  constructor(){    super()    this.state={      name:'alien'    }  }  say(){    console.log('base components')  }  render(){    return &lt;div&gt; hello,world &lt;button onClick={ this.say.bind(this) } &gt;点击&lt;/button&gt;  &lt;/div&gt;  }}class Index extends Base{  componentDidMount(){    console.log( this.state.name )  }  say(){ /* 会覆盖基类中的 say  */    console.log('extends components')  }}export default Index
</code></pre></div><h3 id="_3hoc模式"><a href="#_3hoc模式" class="header-anchor">#</a> ③HOC模式</h3> <p><strong>原型图</strong></p> <p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdwcFr2v6wCVYKr2wsh0KZRXYs6OvOe4Jzm27Vl3bXG29H12prn2V3n5IicRuicMJJvUciagxmiamn5SPg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p> <p><code>HOC</code>是我们本章主要的讲的内容，具体用法，我们接下来会慢慢道来，我们先简单尝试一个<code>HOC</code>。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC(Component) {  return class wrapComponent extends React.Component{     constructor(){       super()       this.state={         name:'alien'       }     }     render=()=&gt;&lt;Component { ...this.props } { ...this.state } /&gt;  }}
@HOCclass Index extends React.Component{  say(){    const { name } = this.props    console.log(name)  }  render(){    return &lt;div&gt; hello,world &lt;button onClick={ this.say.bind(this) } &gt;点击&lt;/button&gt;  &lt;/div&gt;  }}
</code></pre></div><h3 id="_4自定义hooks模式"><a href="#_4自定义hooks模式" class="header-anchor">#</a> ④自定义hooks模式</h3> <p><strong>原型图</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p><code>hooks</code>的诞生，一大部分原因是解决<strong>无状态组件没有<code>state</code>**和**逻辑难以复用</strong>问题。<code>hooks</code>可以将一段逻辑封装起来，做到开箱即用，我这里就不多讲了，接下来会出<code>react-hooks</code>原理的文章，完成<code>react-hooks</code>三部曲。感兴趣的同学可以看笔者的另外二篇文章，里面详细介绍了<code>react-hooks</code>复用代码逻辑的原则和方案。</p> <p>传送门：</p> <p>玩转react-hooks,自定义hooks设计模式及其实战</p> <p>react-hooks如何使用？</p> <h2 id="_2-高阶组件产生初衷"><a href="#_2-高阶组件产生初衷" class="header-anchor">#</a> 2 高阶组件产生初衷</h2> <p>组件是把<code>prop</code>渲染成<code>UI</code>,而高阶组件是将组件转换成另外一个组件，我们更应该注意的是，经过包装后的组件，获得了那些强化,节省多少逻辑，或是解决了原有组件的那些缺陷，这就是高阶组件的意义。我们先来思考一下高阶组件究竟解决了什么问题🤔🤔🤔？</p> <p><strong>① 复用逻辑</strong>：高阶组件更像是一个加工<code>react</code>组件的工厂，批量对原有组件进行<strong>加工</strong>，<strong>包装</strong>处理。我们可以根据业务需求定制化专属的<code>HOC</code>,这样可以解决复用逻辑。</p> <p><strong>② 强化props</strong>：这个是<code>HOC</code>最常用的用法之一，高阶组件返回的组件，可以劫持上一层传过来的<code>props</code>,然后混入新的<code>props</code>,来增强组件的功能。代表作<code>react-router</code>中的<code>withRouter</code>。</p> <p><strong>③ 赋能组件</strong>：<code>HOC</code>有一项独特的特性，就是可以给被<code>HOC</code>包裹的业务组件，提供一些拓展功能，比如说<strong>额外的生命周期，额外的事件</strong>，但是这种<code>HOC</code>，可能需要和业务组件紧密结合。典型案例<code>react-keepalive-router</code>中的 <code>keepaliveLifeCycle</code>就是通过<code>HOC</code>方式，给业务组件增加了额外的生命周期。</p> <p><strong>④ 控制渲染</strong>：劫持渲染是<code>hoc</code>一个特性，在<code>wrapComponent</code>包装组件中，可以对原来的组件，进行<code>条件渲染</code>，<code>节流渲染</code>，<code>懒加载</code>等功能，后面会详细讲解，典型代表做<code>react-redux</code>中<code>connect</code>和 <code>dva</code>中 <code>dynamic</code> 组件懒加载。</p> <p>我会针对高阶组件的初衷展开，详细介绍其原理已经用法。跟上我的思路，我们先来看一下，高阶组件<strong>如何在我们的业务组件中使用的</strong>。</p> <h2 id="_3-高阶组件使用和编写结构"><a href="#_3-高阶组件使用和编写结构" class="header-anchor">#</a> 3 高阶组件使用和编写结构</h2> <p><code>HOC</code>使用指南是非常简单的，只需要将我们的组件进行包裹就可以了。</p> <h3 id="使用-装饰器模式和函数包裹模式"><a href="#使用-装饰器模式和函数包裹模式" class="header-anchor">#</a> 使用：装饰器模式和函数包裹模式</h3> <p>对于<code>class</code>声明的有状态组件，我们可以用装饰器模式，对类组件进行包装：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>@withStyles(styles)@withRouter@keepaliveLifeCycleclass Index extends React.Componen{    /* ... */}
</code></pre></div><p><strong>我们要注意一下包装顺序，越靠近<code>Index</code>组件的，就是越内层的<code>HOC</code>,离组件<code>Index</code>也就越近。</strong></p> <p>对于无状态组件(函数声明）我们可以这么写：</p> <ul><li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Index(){    /* .... */}export default withStyles(styles)(withRouter( keepaliveLifeCycle(Index) )) 
</code></pre></div><h3 id="模型-嵌套hoc"><a href="#模型-嵌套hoc" class="header-anchor">#</a> 模型：嵌套HOC</h3> <p>对于不需要传递参数的<code>HOC</code>，我们编写模型我们只需要嵌套一层就可以，比如<code>withRouter</code>,</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function withRouter(){    return class wrapComponent extends React.Component{        /* 编写逻辑 */    }}
</code></pre></div><p>对于需要参数的<code>HOC</code>，我们需要一层代理，如下：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function connect (mapStateToProps){    /* 接受第一个参数 */    return function connectAdvance(wrapCompoent){        /* 接受组件 */        return class WrapComponent extends React.Component{  }    }}
</code></pre></div><p>我们看出两种<code>hoc</code>模型很简单，对于代理函数，可能有一层，可能有很多层，不过不要怕，无论多少层本质上都是一样的，我们只需要一层一层剥离开，分析结构，整个<code>hoc</code>结构和脉络就会清晰可见。吃透<code>hoc</code>也就易如反掌。</p> <h2 id="_4-两种不同的高阶组件"><a href="#_4-两种不同的高阶组件" class="header-anchor">#</a> 4 两种不同的高阶组件</h2> <p>常用的高阶组件有两种方式<strong>正向的属性代理</strong>和<strong>反向的组件继承</strong>，两者之前有一些共性和区别。接下具体介绍两者区别，在第三部分会详细介绍具体实现。</p> <h3 id="正向属性代理"><a href="#正向属性代理" class="header-anchor">#</a> 正向属性代理</h3> <p>所谓正向属性代理，就是用组件包裹一层代理组件，在代理组件上，我们可以做一些，对源组件的代理操作。在<code>fiber tree</code> 上，先<code>mounted</code>代理组件，然后才是我们的业务组件。我们可以理解为父子组件关系，父组件对子组件进行一系列强化操作。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC(WrapComponent){    return class Advance extends React.Component{       state={           name:'alien'       }       render(){           return &lt;WrapComponent  { ...this.props } { ...this.state }  /&gt;       }    }}
</code></pre></div><h4 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h4> <ul><li>① 正常属性代理可以和业务组件低耦合，零耦合，对于<code>条件渲染</code>和<code>props属性增强</code>,只负责控制子组件渲染和传递额外的<code>props</code>就可以，所以无须知道，业务组件做了些什么。所以正向属性代理，更适合做一些开源项目的<code>hoc</code>，目前开源的<code>HOC</code>基本都是通过这个模式实现的。</li> <li>② 同样适用于<code>class</code>声明组件，和<code>function</code>声明的组件。</li> <li>③ 可以完全隔离业务组件的渲染,相比反向继承，属性代理这种模式。可以完全控制业务组件渲染与否，可以避免<code>反向继承</code>带来一些副作用，比如生命周期的执行。</li> <li>④ 可以嵌套使用，多个<code>hoc</code>是可以嵌套使用的，而且一般不会限制包装<code>HOC</code>的先后顺序。</li></ul> <h4 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h4> <ul><li>① 一般无法直接获取业务组件的状态，如果想要获取，需要<code>ref</code>获取组件实例。</li> <li>② 无法直接继承静态属性。如果需要继承需要手动处理，或者引入第三方库。</li></ul> <p><strong>例子：</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{  render(){    return &lt;div&gt; hello,world  &lt;/div&gt;  }}Index.say = function(){  console.log('my name is alien')}function HOC(Component) {  return class wrapComponent extends React.Component{     render(){       return &lt;Component { ...this.props } { ...this.state } /&gt;     }  }}const newIndex =  HOC(Index) console.log(newIndex.say)
</code></pre></div><p><strong>打印结果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h3 id="反向继承"><a href="#反向继承" class="header-anchor">#</a> 反向继承</h3> <p>反向继承和属性代理有一定的区别，在于包装后的组件继承了业务组件本身，所以我们我无须在去实例化我们的业务组件。当前高阶组件就是继承后，加强型的业务组件。这种方式类似于组件的强化，所以你必要要知道当前</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{  render(){    return &lt;div&gt; hello,world  &lt;/div&gt;  }}function HOC(Component){    return class wrapComponent extends Component{ /* 直接继承需要包装的组件 */
    }}export default HOC(Index)
</code></pre></div><h4 id="优点-2"><a href="#优点-2" class="header-anchor">#</a> 优点</h4> <ul><li><p>① 方便获取组件内部状态，比如<code>state</code>，<code>props</code> ,生命周期,绑定的事件函数等</p></li> <li><p>② <code>es6</code>继承可以良好继承静态属性。我们无须对静态属性和方法进行额外的处理。</p></li> <li><ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{  render(){    return &lt;div&gt; hello,world  &lt;/div&gt;  }}Index.say = function(){  console.log('my name is alien')}function HOC(Component) {  return class wrapComponent extends Component{  }}const newIndex =  HOC(Index) console.log(newIndex.say)
</code></pre></div></li></ul> <p><strong>打印结果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h4 id="缺点-2"><a href="#缺点-2" class="header-anchor">#</a> 缺点</h4> <ul><li>① 无状态组件无法使用。</li> <li>② 和被包装的组件强耦合，需要知道被包装的组件的内部状态，具体是做什么？</li> <li>③ 如果多个反向继承<code>hoc</code>嵌套在一起，当前状态会覆盖上一个状态。这样带来的隐患是非常大的，比如说有多个<code>componentDidMount</code>，当前<code>componentDidMount</code>会覆盖上一个<code>componentDidMount</code>。这样副作用串联起来，影响很大。</li></ul> <h1 id="三-如何编写高阶组件"><a href="#三-如何编写高阶组件" class="header-anchor">#</a> 三 如何编写高阶组件</h1> <p>接下来我们来看看，如何编写一个高阶组件，你可以参考如下的情景，去编写属于自己的<code>HOC</code>。</p> <h2 id="_1-强化props"><a href="#_1-强化props" class="header-anchor">#</a> 1 强化props</h2> <h3 id="_1-混入props"><a href="#_1-混入props" class="header-anchor">#</a> ① 混入props</h3> <p>这个是高阶组件最常用的功能，承接上层的<code>props</code>,在混入自己的<code>props</code>，来强化组件。</p> <p><strong>有状态组件(属性代理)</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function classHOC(WrapComponent){    return class  Idex extends React.Component{        state={            name:'alien'        }        componentDidMount(){           console.log('HOC')        }        render(){            return &lt;WrapComponent { ...this.props }  { ...this.state }   /&gt;        }    }}function Index(props){  const { name } = props  useEffect(()=&gt;{     console.log( 'index' )  },[])  return &lt;div&gt;    hello,world , my name is { name }  &lt;/div&gt;}
export default classHOC(Index)
</code></pre></div><p><strong>有状态组件(属性代理)</strong></p> <p>同样也适用与无状态组件。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function functionHoc(WrapComponent){    return function Index(props){        const [ state , setState ] = useState({ name :'alien'  })               return  &lt;WrapComponent { ...props }  { ...state }   /&gt;    }}
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h3 id="_2-抽离state控制更新"><a href="#_2-抽离state控制更新" class="header-anchor">#</a> ② 抽离state控制更新</h3> <p>高阶组件可以将<code>HOC</code>的<code>state</code>的配合起来，控制业务组件的更新。这种用法在<code>react-redux</code>中<code>connect</code>高阶组件中用到过，用于处理来自<code>redux</code>中<code>state</code>更改，带来的订阅更新作用。</p> <p>我们将上述代码进行改造。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function classHOC(WrapComponent){  return class  Idex extends React.Component{      constructor(){        super()        this.state={          name:'alien'        }      }      changeName(name){        this.setState({ name })      }      render(){          return &lt;WrapComponent { ...this.props }  { ...this.state } changeName={this.changeName.bind(this)  }  /&gt;      }  }}function Index(props){  const [ value ,setValue ] = useState(null)  const { name ,changeName } = props  return &lt;div&gt;    &lt;div&gt;   hello,world , my name is { name }&lt;/div&gt;    改变name &lt;input onChange={ (e)=&gt; setValue(e.target.value)  }  /&gt;    &lt;button onClick={ ()=&gt;  changeName(value) }  &gt;确定&lt;/button&gt;  &lt;/div&gt;}
export default classHOC(Index)
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h2 id="_2-控制渲染"><a href="#_2-控制渲染" class="header-anchor">#</a> 2 控制渲染</h2> <p>控制渲染是高阶组件的一个很重要的特性，上边说到的两种高阶组件，都能完成对组件渲染的控制。具体实现还是有区别的，我们一起来探索一下。</p> <h3 id="_2-1-条件渲染"><a href="#_2-1-条件渲染" class="header-anchor">#</a> 2.1 条件渲染</h3> <h4 id="_1-基础-动态渲染"><a href="#_1-基础-动态渲染" class="header-anchor">#</a> ① 基础 ：动态渲染</h4> <p>对于属性代理的高阶组件，虽然不能在内部操控渲染状态，但是可以在外层控制当前组件是否渲染，这种情况应用于，<strong>权限隔离</strong>，<strong>懒加载</strong> ，<strong>延时加载</strong>等场景。</p> <p><strong>实现一个动态挂载组件的HOC</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function renderHOC(WrapComponent){  return class Index  extends React.Component{      constructor(props){        super(props)        this.state={ visible:true }        }      setVisible(){         this.setState({ visible:!this.state.visible })      }      render(){         const {  visible } = this.state          return &lt;div className=&quot;box&quot;  &gt;           &lt;button onClick={ this.setVisible.bind(this) } &gt; 挂载组件 &lt;/button&gt;           { visible ? &lt;WrapComponent { ...this.props } setVisible={ this.setVisible.bind(this) }   /&gt;  : &lt;div className=&quot;icon&quot; &gt;&lt;SyncOutlined spin  className=&quot;theicon&quot;  /&gt;&lt;/div&gt; }         &lt;/div&gt;      }  }}
class Index extends React.Component{  render(){    const { setVisible } = this.props    return &lt;div className=&quot;box&quot; &gt;        &lt;p&gt;hello,my name is alien&lt;/p&gt;        &lt;img  src='https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=294206908,2427609994&amp;fm=26&amp;gp=0.jpg'   /&gt;         &lt;button onClick={() =&gt; setVisible()}  &gt; 卸载当前组件 &lt;/button&gt;    &lt;/div&gt;  }}export default renderHOC(Index)
</code></pre></div><p>效果：</p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h4 id="_2-进阶-分片渲染"><a href="#_2-进阶-分片渲染" class="header-anchor">#</a> ② 进阶 ：分片渲染</h4> <p>是不是感觉不是很过瘾，为了让大家加强对<code>HOC</code>条件渲染的理解，我再做一个<strong>分片渲染+懒加载</strong>功能。为了让大家明白，我也是绞尽脑汁啊😂😂😂。</p> <p><strong>进阶：实现一个懒加载功能的HOC，可以实现组件的分片渲染,用于分片渲染页面，不至于一次渲染大量组件造成白屏效果</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const renderQueue = []let isFirstrender = false
const tryRender = ()=&gt;{  const render = renderQueue.shift()  if(!render) return  setTimeout(()=&gt;{    render() /* 执行下一段渲染 */  },300)} /* HOC */function renderHOC(WrapComponent){    return function Index(props){      const [ isRender , setRender ] = useState(false)      useEffect(()=&gt;{        renderQueue.push(()=&gt;{  /* 放入待渲染队列中 */          setRender(true)        })        if(!isFirstrender) {          tryRender() /**/          isFirstrender = true        }      },[])      return isRender ? &lt;WrapComponent tryRender={tryRender}  { ...props }  /&gt; : &lt;div className='box' &gt;&lt;div className=&quot;icon&quot; &gt;&lt;SyncOutlined   spin /&gt;&lt;/div&gt;&lt;/div&gt;    }}/* 业务组件 */class Index extends React.Component{  componentDidMount(){    const { name , tryRender} = this.props    /* 上一部分渲染完毕，进行下一部分渲染 */    tryRender()    console.log( name+'渲染')  }  render(){    return &lt;div&gt;        &lt;img src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=294206908,2427609994&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; /&gt;    &lt;/div&gt;  }}/* 高阶组件包裹 */const Item = renderHOC(Index)
export default () =&gt; {  return &lt;React.Fragment&gt;      &lt;Item name=&quot;组件一&quot; /&gt;      &lt;Item name=&quot;组件二&quot; /&gt;      &lt;Item name=&quot;组件三&quot; /&gt;  &lt;/React.Fragment&gt;}
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>大致流程，初始化的时候，<code>HOC</code>中将渲染真正组件的渲染函数，放入<code>renderQueue</code>队列中，然后初始化渲染一次，接下来，每一个项目组件，完成 <code>didMounted</code> 状态后，会从队列中取出下一个渲染函数，渲染下一个组件, 一直到所有的渲染任务全部执行完毕，渲染队列清空，有效的进行分片的渲染，这种方式对海量数据展示，很奏效。</p> <p>用<code>HOC</code>实现了条件渲染-分片渲染的功能，实际条件渲染理解起来很容易，就是通过变量，控制是否挂载组件，从而满足项目本身需求，条件渲染可以演变成很多模式，我这里介绍了条件渲染的二种方式，希望大家能够理解精髓所在。</p> <h4 id="_3-进阶-异步组件-懒加载"><a href="#_3-进阶-异步组件-懒加载" class="header-anchor">#</a> ③ 进阶：异步组件(懒加载)</h4> <p>不知道大家有没有用过<code>dva</code>,里面的<code>dynamic</code>就是应用<code>HOC</code>模式实现的组件异步加载，我这里简化了一下，提炼核心代码，如下：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>/* 路由懒加载HOC */export default function AsyncRouter(loadRouter) {  return class Content extends React.Component {    state = {Component: null}    componentDidMount() {      if (this.state.Component) return      loadRouter()        .then(module =&gt; module.default)        .then(Component =&gt; this.setState({Component},         ))    }    render() {      const {Component} = this.state      return Component ? &lt;Component {      ...this.props      }      /&gt; : null    }  }}
</code></pre></div><p>使用</p> <ul><li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const Index = AsyncRouter(()=&gt;import('../pages/index'))
</code></pre></div><p><code>hoc</code>还可以配合其他<code>API</code>，做一下衍生的功能。如上配合<code>import</code>实现异步加载功能。<code>HOC</code>用起来非常灵活，</p> <h4 id="_4-反向继承-渲染劫持"><a href="#_4-反向继承-渲染劫持" class="header-anchor">#</a> ④ 反向继承 ：渲染劫持</h4> <p><strong>HOC反向继承模式，可以实现颗粒化的渲染劫持，也就是可以控制基类组件的<code>render</code>函数，还可以篡改props，或者是<code>children</code>，我们接下来看看，这种状态下，怎么使用高阶组件。</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const HOC = (WrapComponent) =&gt;  class Index  extends WrapComponent {    render() {      if (this.props.visible) {        return super.render()      } else {        return &lt;div&gt;暂无数据&lt;/div&gt;      }    }  }
</code></pre></div><h4 id="_5-反向继承-修改渲染树"><a href="#_5-反向继承-修改渲染树" class="header-anchor">#</a> ⑤ 反向继承：修改渲染树</h4> <p><strong>修改渲染状态(劫持render替换子节点)</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{  render(){    return &lt;div&gt;       &lt;ul&gt;         &lt;li&gt;react&lt;/li&gt;         &lt;li&gt;vue&lt;/li&gt;         &lt;li&gt;Angular&lt;/li&gt;       &lt;/ul&gt;    &lt;/div&gt;  }}
function HOC (Component){  return class Advance extends Component {    render() {      const element = super.render()      const otherProps = {        name:'alien'      }      /* 替换 Angular 元素节点 */      const appendElement = React.createElement('li' ,{} , `hello ,world , my name  is ${ otherProps.name }` )      const newchild =  React.Children.map(element.props.children.props.children,(child,index)=&gt;{           if(index === 2) return appendElement           return  child      })       return  React.cloneElement(element, element.props, newchild)    }  }}export  default HOC(Index)
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>我们用劫持渲染的方式，来操纵<code>super.render()</code>后的<code>React.element</code>元素，然后配合 <code>createElement</code> , <code>cloneElement</code> , <code>React.Children</code> 等 <code>api</code>,可以灵活操纵，真正的渲染<code>react.element</code>，可以说是偷天换日，不亦乐乎。</p> <h3 id="_2-2节流渲染"><a href="#_2-2节流渲染" class="header-anchor">#</a> 2.2节流渲染</h3> <p><code>hoc</code>除了可以进行<strong>条件渲染</strong>，<strong>渲染劫持</strong>功能外，还可以进行节流渲染，也就是可以优化性能，具体怎么做，请跟上我的节奏往下看。</p> <h4 id="_1-基础-节流原理"><a href="#_1-基础-节流原理" class="header-anchor">#</a> ① 基础: 节流原理</h4> <p><code>hoc</code>可以配合<code>hooks</code>的<code>useMemo</code>等<code>API</code>配合使用，可以实现对业务组件的渲染控制，减少渲染次数，从而达到优化性能的效果。如下案例，我们期望当且仅当<code>num</code>改变的时候，渲染组件，但是不影响接收的<code>props</code>。我们应该这样写我们的<code>HOC</code>。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC (Component){     return function renderWrapComponent(props){       const { num } = props       const RenderElement = useMemo(() =&gt;  &lt;Component {...props}  /&gt; ,[ num ])       return RenderElement     }}class Index extends React.Component{  render(){     console.log(`当前组件是否渲染`,this.props)     return &lt;div&gt;hello,world, my name is alien &lt;/div&gt;  }}const IndexHoc = HOC(Index)
export default ()=&gt; {    const [ num ,setNumber ] = useState(0)    const [ num1 ,setNumber1 ] = useState(0)    const [ num2 ,setNumber2 ] = useState(0)    return &lt;div&gt;        &lt;IndexHoc  num={ num } num1={num1} num2={ num2 }  /&gt;        &lt;button onClick={() =&gt; setNumber(num + 1) } &gt;num++&lt;/button&gt;        &lt;button onClick={() =&gt; setNumber1(num1 + 1) } &gt;num1++&lt;/button&gt;        &lt;button onClick={() =&gt; setNumber2(num2 + 1) } &gt;num2++&lt;/button&gt;    &lt;/div&gt;}
</code></pre></div><p><strong>效果：</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>如图所示,当我们只有点击 <code>num++</code>时候，才重新渲染子组件，点击其他按钮，只是负责传递了<code>props</code>,达到了期望的效果。</p> <h4 id="_2-进阶-定制化渲染流"><a href="#_2-进阶-定制化渲染流" class="header-anchor">#</a> ② 进阶：定制化渲染流</h4> <p>思考：🤔上述的案例只是介绍了原理，在实际项目中，是量化生产不了的，原因是，我们需要针对不同<code>props</code>变化，写不同的<code>HOC</code>组件，这样根本起不了<code>Hoc</code>真正的用途，也就是<code>HOC</code>产生的初衷。所以我们需要对上述<code>hoc</code>进行改造升级，是组件可以根据定制化方向，去渲染组件。也就是<code>Hoc</code>生成的时候，已经按照某种契约去执行渲染。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC (rule){     return function (Component){        return function renderWrapComponent(props){          const dep = rule(props)          const RenderElement = useMemo(() =&gt;  &lt;Component {...props}  /&gt; ,[ dep ])          return RenderElement        }     }}/* 只有 props 中 num 变化 ，渲染组件  */@HOC( (props)=&gt; props['num'])class IndexHoc extends React.Component{  render(){     console.log(`组件一渲染`,this.props)     return &lt;div&gt; 组件一 ：hello,world &lt;/div&gt;  }}
/* 只有 props 中 num1 变化 ，渲染组件  */@HOC((props)=&gt; props['num1'])class IndexHoc1 extends React.Component{  render(){     console.log(`组件二渲染`,this.props)     return &lt;div&gt; 组件二 ：my name is alien &lt;/div&gt;  }}export default ()=&gt; {    const [ num ,setNumber ] = useState(0)    const [ num1 ,setNumber1 ] = useState(0)    const [ num2 ,setNumber2 ] = useState(0)    return &lt;div&gt;        &lt;IndexHoc  num={ num } num1={num1} num2={ num2 }  /&gt;        &lt;IndexHoc1  num={ num } num1={num1} num2={ num2 }  /&gt;        &lt;button onClick={() =&gt; setNumber(num + 1) } &gt;num++&lt;/button&gt;        &lt;button onClick={() =&gt; setNumber1(num1 + 1) } &gt;num1++&lt;/button&gt;        &lt;button onClick={() =&gt; setNumber2(num2 + 1) } &gt;num2++&lt;/button&gt;    &lt;/div&gt;}
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>完美实现了效果。这用高阶组件模式，可以灵活控制<code>React</code>组件层面上的，<strong><code>props</code>数据流</strong>和<strong>更新流</strong>，优秀的高阶组件有 <code>mobx</code> 中<code>observer</code> ,<code>inject</code> , <code>react-redux</code>中的<code>connect</code>,感兴趣的同学，可以抽时间研究一下。</p> <h2 id="_3-赋能组件"><a href="#_3-赋能组件" class="header-anchor">#</a> 3 赋能组件</h2> <p>高阶组件除了上述两种功能之外，还可以赋能组件，比如加一些<strong>额外<code>生命周期</code></strong>，<strong>劫持事件</strong>，<strong>监控日志</strong>等等。</p> <h3 id="_3-1-劫持原型链-劫持生命周期-事件函数"><a href="#_3-1-劫持原型链-劫持生命周期-事件函数" class="header-anchor">#</a> 3.1 劫持原型链-劫持生命周期，事件函数</h3> <h4 id="_1-属性代理实现"><a href="#_1-属性代理实现" class="header-anchor">#</a> ① 属性代理实现</h4> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC (Component){  const proDidMount = Component.prototype.componentDidMount   Component.prototype.componentDidMount = function(){     console.log('劫持生命周期：componentDidMount')     proDidMount.call(this)  }  return class wrapComponent extends React.Component{      render(){        return &lt;Component {...this.props}  /&gt;      }  }}@HOCclass Index extends React.Component{   componentDidMount(){     console.log('———didMounted———')   }   render(){     return &lt;div&gt;hello,world&lt;/div&gt;   }}
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h4 id="_2-反向继承实现"><a href="#_2-反向继承实现" class="header-anchor">#</a> ② 反向继承实现</h4> <p>反向继承，因为在继承原有组件的基础上，可以对原有组件的<strong>生命周期</strong>或<strong>事件</strong>进行劫持，甚至是替换。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC (Component){  const didMount = Component.prototype.componentDidMount  return class wrapComponent extends Component{      componentDidMount(){        console.log('------劫持生命周期------')        if (didMount) {           didMount.apply(this) /* 注意 `this` 指向问题。*/        }      }      render(){        return super.render()      }  }}
@HOCclass Index extends React.Component{   componentDidMount(){     console.log('———didMounted———')   }   render(){     return &lt;div&gt;hello,world&lt;/div&gt;   }}
</code></pre></div><h3 id="_3-2-事件监控"><a href="#_3-2-事件监控" class="header-anchor">#</a> 3.2 事件监控</h3> <p><code>HOC</code>还可以对原有组件进行监控。比如对一些<code>事件监控</code>，<code>错误监控</code>，<code>事件监听</code>等一系列操作。</p> <h4 id="_1-组件内的事件监听"><a href="#_1-组件内的事件监听" class="header-anchor">#</a> ① 组件内的事件监听</h4> <p>接下来，我们做一个<code>HOC</code>,只对组件内的点击事件做一个监听效果。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function ClickHoc (Component){  return  function Wrap(props){    const dom = useRef(null)    useEffect(()=&gt;{     const handerClick = () =&gt; console.log('发生点击事件')      dom.current.addEventListener('click',handerClick)     return () =&gt; dom.current.removeEventListener('click',handerClick)    },[])    return  &lt;div ref={dom}  &gt;&lt;Component  {...props} /&gt;&lt;/div&gt;  }}
@ClickHocclass Index extends React.Component{   render(){     return &lt;div  className='index'  &gt;       &lt;p&gt;hello，world&lt;/p&gt;       &lt;button&gt;组件内部点击&lt;/button&gt;    &lt;/div&gt;   }}export default ()=&gt;{  return &lt;div className='box'  &gt;     &lt;Index /&gt;     &lt;button&gt;组件外部点击&lt;/button&gt;  &lt;/div&gt;}
</code></pre></div><p><strong>效果</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <h3 id="_3-ref助力操控组件实例"><a href="#_3-ref助力操控组件实例" class="header-anchor">#</a> 3 ref助力操控组件实例</h3> <p>对于属性代理我们虽然不能直接获取组件内的状态，但是我们可以通过<code>ref</code>获取组件实例,获取到组件实例，就可以获取组件的一些状态，或是手动触发一些事件，进一步强化组件，但是注意的是：<code>class</code>声明的有状态组件才有实例，<code>function</code>声明的无状态组件不存在实例。</p> <h4 id="_1-属性代理-添加额外生命周期"><a href="#_1-属性代理-添加额外生命周期" class="header-anchor">#</a> ① 属性代理-添加额外生命周期</h4> <p>我们可以针对某一种情况, 给组件增加额外的生命周期，我做了一个简单的<code>demo</code>，监听<code>number</code>改变，如果<code>number</code>改变，就自动触发组件的监听函数<code>handerNumberChange</code>。具体写法如下</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Hoc(Component){  return class WrapComponent extends React.Component{      constructor(){        super()        this.node = null      }      UNSAFE_componentWillReceiveProps(nextprops){          if(nextprops.number !== this.props.number ){            this.node.handerNumberChange  &amp;&amp;  this.node.handerNumberChange.call(this.node)          }      }      render(){        return &lt;Component {...this.props} ref={(node) =&gt; this.node = node }  /&gt;      }  }}@Hocclass Index extends React.Component{  handerNumberChange(){      /* 监听 number 改变 */  }  render(){    return &lt;div&gt;hello,world&lt;/div&gt;  }}
</code></pre></div><p>这种写法有点不尽人意，大家不要着急，在第四部分，源码实战中，我会介绍一种更好的场景。方便大家理解<code>Hoc</code>对原有组件的赋能。</p> <h2 id="_4-总结"><a href="#_4-总结" class="header-anchor">#</a> 4 总结</h2> <p>上面我分别按照<code>hoc</code>主要功能，<strong>强化props</strong> ， <strong>控制渲染</strong> ，<strong>赋能组件</strong> 三个方向对<code>HOC</code>编写做了一个详细介绍，和应用场景的介绍，目的<strong>让大家在理解高阶组件的时候，更明白什么时候会用到？,怎么样去写？`</strong> 里面涵盖的知识点我总一个总结。</p> <p>对于属性代理HOC，我们可以：</p> <ul><li>强化props &amp; 抽离state。</li> <li>条件渲染，控制渲染，分片渲染，懒加载。</li> <li>劫持事件和生命周期</li> <li>ref控制组件实例</li> <li>添加事件监听器，日志</li></ul> <p>对于反向代理的HOC,我们可以：</p> <ul><li>劫持渲染，操纵渲染树</li> <li>控制/替换生命周期，直接获取组件状态，绑定事件。</li></ul> <p>每个应用场景，我都举了例子🌰🌰，大家可以结合例子深入了解一下其原理和用途。</p> <h1 id="四-高阶组件源码级实践"><a href="#四-高阶组件源码级实践" class="header-anchor">#</a> 四 高阶组件源码级实践</h1> <p><code>hoc</code>的应用场景有很多，也有很多好的开源项目，供我们学习和参考，接下来我真对三个方向上的功能用途，分别从源码角度解析<code>HOC</code>的用途。</p> <h2 id="_1-强化prop-withroute"><a href="#_1-强化prop-withroute" class="header-anchor">#</a> 1 强化prop- withRoute</h2> <p>用过<code>withRoute</code>的同学，都明白其用途，<code>withRoute</code>用途就是，对于没有被<code>Route</code>包裹的组件，给添加<code>history</code>对象等和路由相关的状态，方便我们在任意组件中，都能够获取路由状态，进行路由跳转，这个<code>HOC</code>目的很清楚，就是强化<code>props</code>,把<code>Router</code>相关的状态都混入到<code>props</code>中，我们看看具体怎么实现的。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function withRouter(Component) {  const displayName = `withRouter(${Component.displayName || Component.name})`;  const C = props =&gt; {      /*  获取 */    const { wrappedComponentRef, ...remainingProps } = props;    return (      &lt;RouterContext.Consumer&gt;        {context =&gt; {          return (            &lt;Component              {...remainingProps}              {...context}              ref={wrappedComponentRef}            /&gt;          );        }}      &lt;/RouterContext.Consumer&gt;    );  };
  C.displayName = displayName;  C.WrappedComponent = Component;  /* 继承静态属性 */  return hoistStatics(C, Component);}
export default withRouter
</code></pre></div><p><code>withRoute</code>的流程实际很简单，就是先从<code>props</code>分离出<code>ref</code>和<code>props</code>,然后从存放整个<code>route</code>对象上下文<code>RouterContext</code>取出<code>route</code>对象,然后混入到原始组件的<code>props</code>中，最后用<code>hoistStatics</code>继承静态属性。至于<code>hoistStatics</code>我们稍后会讲到。</p> <h2 id="_2-控制渲染案例-connect"><a href="#_2-控制渲染案例-connect" class="header-anchor">#</a> 2 控制渲染案例 connect</h2> <p>由于<code>connect</code>源码比较长和难以理解，所以我们提取精髓，精简精简再精简, 总结的核心功能如下,<code>connect</code>的作用也有<code>合并props</code>，但是更重要的是接受<code>state</code>，来控制更新组件。下面这个代码中，为了方便大家理解，我都给简化了。希望大家能够理解<code>hoc</code>如何<strong>派发</strong>和<strong>控制</strong>更新流的。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import store from './redux/store'import { ReactReduxContext } from './Context'import { useContext } from 'react'function connect(mapStateToProps){   /* 第一层：接收订阅state函数 */    return function wrapWithConnect (WrappedComponent){        /* 第二层：接收原始组件 */        function ConnectFunction(props){            const [ , forceUpdate ] = useState(0)            const { reactReduxForwardedRef ,...wrapperProps } = props                        /* 取出Context */            const { store } = useContext(ReactReduxContext)
            /* 强化props：合并 store state 和 props  */            const trueComponentProps = useMemo(()=&gt;{                  /* 只有props或者订阅的state变化，才返回合并后的props */                 return selectorFactory(mapStateToProps(store.getState()),wrapperProps)             },[ store , wrapperProps ])
            /* 只有 trueComponentProps 改变时候,更新组件。*/            const renderedWrappedComponent = useMemo(              () =&gt; (                &lt;WrappedComponent                  {...trueComponentProps}                  ref={reactReduxForwardedRef}                /&gt;              ),              [reactReduxForwardedRef, WrappedComponent, trueComponentProps]            )            useEffect(()=&gt;{              /* 订阅更新 */               const checkUpdate = () =&gt; forceUpdate(new Date().getTime())               store.subscribe( checkUpdate )            },[ store ])            return renderedWrappedComponent        }        /* React.memo 包裹  */        const Connect = React.memo(ConnectFunction)
        /* 处理hoc,获取ref问题 */          if(forwardRef){          const forwarded = React.forwardRef(function forwardConnectRef( props,ref) {            return &lt;Connect {...props} reactReduxForwardedRef={ref} reactReduxForwardedRef={ref} /&gt;          })          return hoistStatics(forwarded, WrappedComponent)        }         /* 继承静态属性 */        return hoistStatics(Connect,WrappedComponent)    } }export default Index
</code></pre></div><p><code>connect</code> 涉及到的功能点还真不少呢，首先第一层接受订阅函数，第二层接收原始组件，然后用<code>forwardRef</code>处理<code>ref</code>,用<code>hoistStatics</code> 处理静态属性的继承，在包装组件内部，合并<code>props</code>,<code>useMemo</code>缓存原始组件，只有合并后的<code>props</code>发生变化，才更新组件，然后在<code>useEffect</code>内部通过<code>store.subscribe()</code>订阅更新。这里省略了<code>Subscription</code>概念，真正的<code>connect</code>中有一个<code>Subscription</code>专门负责订阅消息。</p> <h2 id="_3-赋能组件-缓存生命周期-keepalivelifecycle"><a href="#_3-赋能组件-缓存生命周期-keepalivelifecycle" class="header-anchor">#</a> 3 赋能组件-缓存生命周期 keepaliveLifeCycle</h2> <p>之前笔者写了一个<code>react</code>缓存页面的开源库<code>react-keepalive-router</code>，可以实现<code>vue</code>中 <code>keepalive</code> + <code>router</code>功能，最初的版本没有缓存周期的，但是后来热心读者，期望在被缓存的路由组件中加入缓存周期，类似<code>activated</code>这种的，后来经过我的分析打算用<code>HOC</code>来实现此功能。</p> <p>于是乎<code>react-keepalive-router</code>加入了全新的页面组件生命周期 <code>actived</code> 和 <code>unActived</code>, <code>actived</code> 作为缓存路由组件激活时候用，初始化的时候会默认执行一次 , <code>unActived</code> 作为路由组件缓存完成后调用。但是生命周期需要用一个 <code>HOC</code> 组件<code>keepaliveLifeCycle</code> 包裹。</p> <p>使用</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import React   from 'react'import { keepaliveLifeCycle } from 'react-keepalive-router'
@keepaliveLifeCycleclass index extends React.Component&lt;any,any&gt;{
    state={        activedNumber:0,        unActivedNumber:0    }    actived(){        this.setState({            activedNumber:this.state.activedNumber + 1        })    }    unActived(){        this.setState({            unActivedNumber:this.state.unActivedNumber + 1        })    }    render(){        const { activedNumber , unActivedNumber } = this.state        return &lt;div  style={{ marginTop :'50px' }}  &gt;           &lt;div&gt; 页面 actived 次数：{activedNumber} &lt;/div&gt;           &lt;div&gt; 页面 unActived 次数：{unActivedNumber} &lt;/div&gt;        &lt;/div&gt;    }}export default index
</code></pre></div><p>**
**</p> <p><strong>原理</strong></p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import {lifeCycles} from '../core/keeper'import hoistNonReactStatic from 'hoist-non-react-statics'function keepaliveLifeCycle(Component) {   class Hoc extends React.Component {    cur = null    handerLifeCycle = type =&gt; {      if (!this.cur) return      const lifeCycleFunc = this.cur[type]      isFuntion(lifeCycleFunc) &amp;&amp; lifeCycleFunc.call(this.cur)    }    componentDidMount() {       const {cacheId} = this.props      cacheId &amp;&amp; (lifeCycles[cacheId] = this.handerLifeCycle)    }    componentWillUnmount() {      const {cacheId} = this.props      delete lifeCycles[cacheId]    }     render=() =&gt; &lt;Component {...this.props} ref={cur =&gt; (this.cur = cur)}/&gt;  }  return hoistNonReactStatic(Hoc,Component)}
</code></pre></div><p><code>keepaliveLifeCycle</code> 的原理很简单，就是通过<code>ref</code>或获取 <code>class</code> 组件的实例,在 <code>hoc</code> 初始化时候<strong>进行生命周期的绑定</strong>, 在 <code>hoc</code> 销毁阶段，对生命周期进行解绑, 然后交给<code>keeper</code>统一调度，<code>keeper</code>通过调用实例下面的生命周期函数，来实现缓存生命周期功能的。</p> <h1 id="五-高阶组件的注意事项"><a href="#五-高阶组件的注意事项" class="header-anchor">#</a> 五 高阶组件的注意事项</h1> <h2 id="_1-谨慎修改原型链"><a href="#_1-谨慎修改原型链" class="header-anchor">#</a> 1 谨慎修改原型链</h2> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC (Component){  const proDidMount = Component.prototype.componentDidMount   Component.prototype.componentDidMount = function(){     console.log('劫持生命周期：componentDidMount')     proDidMount.call(this)  }  return  Component}
</code></pre></div><p>这样做会产生一些不良后果。比如如果你再用另一个同样会修改 <code>componentDidMount</code> 的 <code>HOC</code> 增强它，那么前面的 <code>HOC</code> 就会失效！同时，这个 <code>HOC</code> 也无法应用于没有生命周期的函数组件。</p> <h2 id="_2-继承静态属性"><a href="#_2-继承静态属性" class="header-anchor">#</a> 2 继承静态属性</h2> <p>在用属性代理的方式编写<code>HOC</code>的时候，要注意的是就是，静态属性丢失的问题，前面提到了，如果不做处理，静态方法就会全部丢失。</p> <h3 id="手动继承"><a href="#手动继承" class="header-anchor">#</a> 手动继承</h3> <p>我们可以手动将原始组件的静态方法<code>copy</code>到 <code>hoc</code>组件上来，但前提是必须准确知道应该拷贝哪些方法。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>function HOC(Component) {  class WrappedComponent extends React.Component {      /*...*/  }  // 必须准确知道应该拷贝哪些方法   WrappedComponent.staticMethod = Component.staticMethod  return WrappedComponent}
</code></pre></div><h3 id="引入第三方库"><a href="#引入第三方库" class="header-anchor">#</a> 引入第三方库</h3> <p>这样每个静态方法都绑定会很累，尤其对于开源的<code>hoc</code>，<strong>对原生组件的静态方法是未知的</strong>,我们可以使用 <code>hoist-non-react-statics</code> 自动拷贝所有的静态方法:</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>import hoistNonReactStatic from 'hoist-non-react-statics'function HOC(Component) {  class WrappedComponent extends React.Component {      /*...*/  }  hoistNonReactStatic(WrappedComponent,Component)  return WrappedComponent}
</code></pre></div><h2 id="_3-跨层级捕获ref"><a href="#_3-跨层级捕获ref" class="header-anchor">#</a> 3 跨层级捕获ref</h2> <p>高阶组件的约定是将所有 <code>props</code> 传递给被包装组件，但这对于 <code>refs</code> 并不适用。那是因为 <code>ref</code> 实际上并不是一个 <code>prop</code> - 就像 <code>key</code> 一样，它是由 <code>React</code> 专门处理的。如果将 <code>ref</code> 添加到 <code>HOC</code> 的返回组件中，则 <code>ref</code> 引用指向容器组件，而不是被包装组件。我们可以通过<code>forwardRef</code>来解决这个问题。</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>/** *  * @param {*} Component 原始组件 * @param {*} isRef  是否开启ref模式 */function HOC(Component,isRef){  class Wrap extends React.Component{     render(){        const { forwardedRef ,...otherprops  } = this.props        return &lt;Component ref={forwardedRef}  {...otherprops}  /&gt;     }  }    if(isRef){      return  React.forwardRef((props,ref)=&gt; &lt;Wrap forwardedRef={ref} {...props} /&gt; )    }    return Wrap}
class Index extends React.Component{  componentDidMount(){      console.log(666)  }  render(){    return &lt;div&gt;hello,world&lt;/div&gt;  }}
const HocIndex =  HOC(Index,true)
export default ()=&gt;{  const node = useRef(null)  useEffect(()=&gt;{     /* 就可以跨层级，捕获到 Index 组件的实例了 */     console.log(node.current.componentDidMount)  },[])  return &lt;div&gt;&lt;HocIndex ref={node}  /&gt;&lt;/div&gt;}
</code></pre></div><p><strong>打印结果：</strong></p> <p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p> <p>如上就解决了,<code>HOC</code>跨层级捕获<code>ref</code>的问题。</p> <h2 id="_4-render中不要声明hoc"><a href="#_4-render中不要声明hoc" class="header-anchor">#</a> 4 render中不要声明HOC</h2> <p>🙅错误写法：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>class Index extends React.Component{  render(){     const WrapHome = HOC(Home)     return &lt;WrapHome /&gt;  }}
</code></pre></div><p>如果这么写，会造成一个极大的问题，因为每一次<code>HOC</code>都会返回一个新的<code>WrapHome</code>,<code>react diff</code>会判定两次<strong>不是同一个组件</strong>，那么每次<code>Index</code> 组件 <code>render</code>触发，<code>WrapHome</code>，会重新挂载，状态会<strong>全都丢失</strong>。如果想要动态绑定<code>HOC</code>,请参考如下方式。</p> <p>🙆正确写法：</p> <ul><li></li> <li></li> <li></li> <li></li> <li></li> <li></li></ul> <div class="language- extra-class"><pre class="language-text"><code>const WrapHome = HOC(Home)class index extends React.Component{  render(){     return &lt;WrapHome /&gt;  }}
</code></pre></div><h1 id="六-总结"><a href="#六-总结" class="header-anchor">#</a> 六 总结</h1> <p>本文从高阶组件功能为切入点，介绍二种不同的高阶组件如何编写，应用场景，以及实践。涵盖了大部分耳熟能详的开源高阶组件的应用场景，如果你觉得这篇文章对你有启发，最好还是按照文章中的<code>demo</code>，跟着敲一遍，加深印象，知道什么场景用高阶组件，怎么用高阶组件。</p> <p><code>实践是检验真理的唯一标准</code>，希望大家能把高阶组件<code>码</code>起来，用起来。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">11/8/2024, 10:19:43 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/react/2-进阶/setState执行机制.html" class="prev">
        setState 执行机制
      </a></span> <span class="next"><a href="/react/2-进阶/五分钟带你掌握优先队列.html">
        五分钟带你掌握优先队列
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.ae400df5.js" defer></script><script src="/assets/js/2.57da4f88.js" defer></script><script src="/assets/js/1.a76cc220.js" defer></script><script src="/assets/js/467.e6370736.js" defer></script>
  </body>
</html>
